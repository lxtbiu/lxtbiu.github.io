<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础(五)</title>
      <link href="/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E4%BA%94/"/>
      <url>/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java复习主要内容：Collection集合，迭代器，增强for（for-each），泛型，List集合，Set集合，Collections集合工具类，Map集合。</p> <a id="more"></a><h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2 集合框架"></a>1.2 集合框架</h2><p>集合按照其存储结构可以分为两大类:</p><p>分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code></p><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h1 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p><code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p><strong>迭代的概念</strong></p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-泛型的定义和使用"><a href="#3-2-泛型的定义和使用" class="headerlink" title="3.2 泛型的定义和使用"></a>3.2 泛型的定义和使用</h2><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;</span>  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">修饰符 <span class="tag">&lt;<span class="name">代表泛型的变量</span>&gt;</span> 返回值类型 方法名(参数)</span><span class="template-variable">&#123;  &#125;</span></span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><h2 id="3-3-泛型通配符"><a href="#3-3-泛型通配符" class="headerlink" title="3.3 泛型通配符"></a>3.3 泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用.</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>举例：</p><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-List集合"><a href="#第四章-List集合" class="headerlink" title="第四章 List集合"></a>第四章 List集合</h1><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p>在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，<strong>List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致</strong>。</p><p><strong>List接口特点：</strong></p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><h1 id="第五章-List的子类"><a href="#第五章-List的子类" class="headerlink" title="第五章 List的子类"></a>第五章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合，查询慢，增删快。</p><p>方法：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><h1 id="第六章-Set接口"><a href="#第六章-Set接口" class="headerlink" title="第六章 Set接口"></a>第六章 Set接口</h1><p><strong>Set</strong>接口与<strong>List</strong>接口一样，同样继承<strong>Collection</strong>接口，与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，不重复的，并且都会以某种规则保证存入的元素不出现重复。</p><p>Set集合取出元素的方式可以采用：迭代器、增强for。</p><h2 id="6-1-HashSet集合"><a href="#6-1-HashSet集合" class="headerlink" title="6.1 HashSet集合"></a>6.1 HashSet集合</h2><p><code>HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)，<code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><h2 id="6-2-HashSet集合存储数据的结构（哈希表）"><a href="#6-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="6.2 HashSet集合存储数据的结构（哈希表）"></a>6.2 HashSet集合存储数据的结构（哈希表）</h2><p><strong>什么是哈希表呢？</strong></p><p>哈希表就是一种以 键-值(key-value ) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。 </p><p>在JDK1.8中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</p><p><strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式</p><h2 id="6-3-HashSet存储自定义类型元素"><a href="#6-3-HashSet存储自定义类型元素" class="headerlink" title="6.3 HashSet存储自定义类型元素"></a>6.3 HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><h2 id="6-4-LinkedHashSet"><a href="#6-4-LinkedHashSet" class="headerlink" title="6.4 LinkedHashSet"></a>6.4 LinkedHashSet</h2><p>HashSet可以保证元素唯一，但是元素存放是无序的，而需要有序的是在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><h1 id="第七章-Collections"><a href="#第七章-Collections" class="headerlink" title="第七章 Collections"></a>第七章 Collections</h1><h2 id="7-1-常用功能"><a href="#7-1-常用功能" class="headerlink" title="7.1 常用功能"></a>7.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><h1 id="第八章-Map集合"><a href="#第八章-Map集合" class="headerlink" title="第八章 Map集合"></a>第八章 Map集合</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="8-2-Map常用子类"><a href="#8-2-Map常用子类" class="headerlink" title="8.2  Map常用子类"></a>8.2  Map常用子类</h2><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap&lt;K,V&gt;</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><h2 id="8-3-Map接口中的常用方法"><a href="#8-3-Map接口中的常用方法" class="headerlink" title="8.3 Map接口中的常用方法"></a>8.3 Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="8-4-Map集合遍历键找值方式"><a href="#8-4-Map集合遍历键找值方式" class="headerlink" title="8.4 Map集合遍历键找值方式"></a>8.4 Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          <span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"的CP是："</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-Entry键值对对象"><a href="#8-5-Entry键值对对象" class="headerlink" title="8.5  Entry键值对对象"></a>8.5  Entry键值对对象</h2><p><code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。</p><p>Entry表示了一对键和值，提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="8-6-Map集合遍历键值对方式"><a href="#8-6-Map集合遍历键值对方式" class="headerlink" title="8.6 Map集合遍历键值对方式"></a>8.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           <span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">"的CP是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-7-HashMap存储自定义类型键值"><a href="#8-7-HashMap存储自定义类型键值" class="headerlink" title="8.7 HashMap存储自定义类型键值"></a>8.7 HashMap存储自定义类型键值</h2><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="8-8-LinkedHashMap"><a href="#8-8-LinkedHashMap" class="headerlink" title="8.8   LinkedHashMap"></a>8.8   LinkedHashMap</h2><p><strong>LinkedHashMap</strong>保证有序即map中存放的key和取出的顺序一致，它是链表和哈希表组合的一个数据存储结构。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础(五) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(四)</title>
      <link href="/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E5%9B%9B/"/>
      <url>/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java基础复习，Object类和常用API，主要内容有：Object类，Object类，DateFormat类，Calendar类，System类，StringBuilder类，包装类。</p> <a id="more"></a><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h2><table><thead><tr><th>方法</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>clone()</td><td>创建并返回此对象的副本</td><td>Object</td></tr><tr><td>equals(Object obj)</td><td>指示一些其他对象是否等于此</td><td>boolen</td></tr><tr><td>finalize()</td><td>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象</td><td>void</td></tr><tr><td>getClass()</td><td>返回此 <code>Object</code>的运行时类。</td><td>类&lt;?&gt;</td></tr><tr><td>hashCode()</td><td>返回对象的哈希码值。</td><td>int</td></tr><tr><td>notify()</td><td>唤醒正在等待对象监视器的单个线程。</td><td>void</td></tr><tr><td>notifyAll()</td><td>唤醒正在等待对象监视器的所有线程。</td><td>void</td></tr><tr><td>toString()</td><td>返回对象的字符串表示形式。</td><td>String</td></tr><tr><td>wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td><td>void</td></tr><tr><td>wait(long timeout)</td><td>导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过。</td><td>void</td></tr><tr><td>wait(long timeout, int nanos)</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，或一定量的实时时间</td><td>void</td></tr></tbody></table><p><strong>Object类当中包含的方法有11个。</strong>其中最为常见的为</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-3-toString-方法"><a href="#1-3-toString-方法" class="headerlink" title="1.3 toString 方法"></a>1.3 toString 方法</h2><h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-equals方法"><a href="#1-4-equals方法" class="headerlink" title="1.4 equals方法"></a>1.4 equals方法</h2><h3 id="方法说明-1"><a href="#方法说明-1" class="headerlink" title="方法说明"></a>方法说明</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-补充"><a href="#1-5-补充" class="headerlink" title="1.5 补充"></a>1.5 补充</h2><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><ul><li><p><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</p></li><li><p><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</p></li><li><p><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</p></li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，可以完成完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h2 id="2-3-Calendar类"><a href="#2-3-Calendar类" class="headerlink" title="2.3 Calendar类"></a>2.3 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h2 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h2><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h3 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h3><p>currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h3><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Hello"</span>;</span><br><span class="line">        s += <span class="string">"World"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-概述"><a href="#4-2-概述" class="headerlink" title="4.2 概述"></a>4.2 概述</h2><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。(默认16字符空间，超过自动扩充)</p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h2 id="5-3-自动装箱与自动拆箱"><a href="#5-3-自动装箱与自动拆箱" class="headerlink" title="5.3 自动装箱与自动拆箱"></a>5.3 自动装箱与自动拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line"></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h2 id="5-4-基本类型与字符串之间的转换"><a href="#5-4-基本类型与字符串之间的转换" class="headerlink" title="5.4  基本类型与字符串之间的转换"></a>5.4  基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p><strong>基本类型转换String总共有三种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式（最常用）</span></span><br><span class="line">String s1 = a + <span class="string">""</span>;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">String s2 = String.valueOf(a);</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">Integer b = a;</span><br><span class="line">String s3 = b.toString();</span><br></pre></td></tr></table></figure><p><strong>String转换成对应的基本类型</strong> </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>以Integer类的静态方法parseXxx为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础(四) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(三)</title>
      <link href="/2020/01/27/Java%E5%9F%BA%E7%A1%80-%E4%B8%89/"/>
      <url>/2020/01/27/Java%E5%9F%BA%E7%A1%80-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java基础复习，本篇博客写了继承、多态、抽象类、接口内部类、final关键字、权限修饰符，继续加油吧少年！！</p> <a id="more"></a><h1 id="第一章-继承"><a href="#第一章-继承" class="headerlink" title="第一章 继承"></a>第一章 继承</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>定义</strong></p><ul><li><strong>继承：</strong> 就是子类继承父类的属性和行为，使得子类具有父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</li></ul><p><strong>好处</strong></p><ol><li>提高代码的复用性。</li><li>类与类之间产生了关系，是多态的前提。</li></ol><h2 id="1-2-继承的格式"><a href="#1-2-继承的格式" class="headerlink" title="1.2 继承的格式"></a>1.2 继承的格式</h2><p>通过extends关键字，可以声明一个子类继承另外一个父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-继承后的特点—-成员变量"><a href="#1-3-继承后的特点—-成员变量" class="headerlink" title="1.3 继承后的特点—-成员变量"></a>1.3 继承后的特点—-成员变量</h2><p><strong>成员变量不重名</strong></p><p>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</p><p><strong>成员变量重名</strong></p><p>如果子类和父类中出现重名的成员变量时，在子类中需要访问父类中非私有成员的变量时，需要使用<strong>super</strong>关键字，修饰父类成员变量，类似于之前学过的<strong>this</strong>。</p><p>使用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure><p>注意：父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类不可以直接访问，如果要访问父类的私有成员变量，可以在父类中提供<strong>getxxx</strong>和<strong>setxxx</strong>方法。</p><h2 id="1-4继承后的特点—-成员方法"><a href="#1-4继承后的特点—-成员方法" class="headerlink" title="1.4继承后的特点—-成员方法"></a>1.4继承后的特点—-成员方法</h2><p><strong>成员方法不重名</strong></p><p> 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对 应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 </p><p><strong>成员方法重名—-重写（Override）</strong></p><p>如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写</strong>(Override)</p><ul><li><strong>方法重写</strong>：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都会相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现。</strong></li></ul><p><strong>注意事项</strong></p><ol><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h2 id="1-5-继承后的特点—–构造方法"><a href="#1-5-继承后的特点—–构造方法" class="headerlink" title="1.5 继承后的特点—–构造方法"></a>1.5 继承后的特点—–构造方法</h2><p><strong>构造方法定义格式和作用</strong></p><ol><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。 所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构 造方法中默认有一个 <strong>super()</strong> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 </li></ol><h2 id="1-6-super和this"><a href="#1-6-super和this" class="headerlink" title="1.6 super和this"></a>1.6 super和this</h2><p><strong>父类空间优于子类对象产生</strong></p><p><strong>super和this的含义</strong></p><ul><li><strong>super</strong>：代表父类的存储空间标识（可以理解为父亲的引用）。</li><li><strong>this</strong>：代表当前对象的引用（谁调用就代表谁）。</li></ul><p><strong>super和this的用法</strong></p><ol><li><strong>访问成员</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量 ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员变量 ‐‐ 父类的</span><br><span class="line"><span class="keyword">this</span>.成员方法名() ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员方法名() ‐‐ 父类的</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>访问构造方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>(...)--本类的构造方法</span><br><span class="line"><span class="keyword">super</span>(...)--父类的构造方法</span><br></pre></td></tr></table></figure><p> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 </p><h2 id="1-7-继承的特点"><a href="#1-7-继承的特点" class="headerlink" title="1.7 继承的特点"></a>1.7 继承的特点</h2><ol><li>Java只支持单继承，不支持多继承。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">//正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;&#125;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Java支持多层继承</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 顶层父类是Object类。所有的类默认继承Object，作为父类。 </p><h1 id="第二章-抽象类"><a href="#第二章-抽象类" class="headerlink" title="第二章 抽象类"></a>第二章 抽象类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><strong>由来</strong></p><p> 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。  <strong>包含抽象方法 的类就是抽象类。</strong> </p><p><strong>定义</strong></p><ul><li>抽象方法：没有方法体的方法。</li><li>抽象类：包含抽象方法的类。</li></ul><h2 id="2-2-abstract使用格式"><a href="#2-2-abstract使用格式" class="headerlink" title="2.2 abstract使用格式"></a>2.2 abstract使用格式</h2><p><strong>抽象方法</strong></p><p>使用abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p><strong>定义格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表)；</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>抽象类</strong></p><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名字</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象的使用</strong></p><p> 继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父 类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 </p><h2 id="2-3-注意事项"><a href="#2-3-注意事项" class="headerlink" title="2.3 注意事项"></a>2.3 注意事项</h2><ol><li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。  </li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。  </li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 </li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象 类。  </li></ol><h1 id="第三章-接口"><a href="#第三章-接口" class="headerlink" title="第三章 接口"></a>第三章 接口</h1><h2 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p> 接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么 接口的内部主要就是封装了方法，.</p><p> 接口的定义，它与定义类方式相似，但是使用 interface 关键字。 </p><p>引用数据类型：数组，类，接口。</p><p> 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做 是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><h2 id="1-2-定义格式"><a href="#1-2-定义格式" class="headerlink" title="1.2 定义格式"></a>1.2 定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="comment">//默认方法</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有抽象方法</strong></p><p>抽象方法：使用abstract关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有默认方法和静态方法</strong></p><p>默认方法：使用default修饰，不可省略，供子类调用或者子类重写。</p><p>静态方法：使用static修饰，供接口直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有私有方法和私有静态方法</strong></p><p>私有方法：使用private修饰，供接口中的默认方法或者静态方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-基本实现"><a href="#1-3-基本实现" class="headerlink" title="1.3 基本实现"></a>1.3 基本实现</h2><p><strong>实现的概述</strong></p><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。</p><p>非抽象子类实现接口</p><ol><li>必须重写接口中所有的抽象方法</li><li>继承了接口的默认方法，即可以直接调用，也可以重写</li></ol><p>实现格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line"><span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>抽象方法的使用</strong> </p><p>必须全部实现 </p><p> <strong>默认方法的使用</strong> </p><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 </p><p> <strong>静态方法的使用</strong> </p><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 </p><p> <strong>私有方法的使用</strong> </p><ul><li><p>私有方法：只有默认方法可以调用。 </p></li><li><p>私有静态方法：默认方法和静态方法可以调用 </p></li></ul><h2 id="1-4-接口的多实现"><a href="#1-4-接口的多实现" class="headerlink" title="1.4 接口的多实现"></a>1.4 接口的多实现</h2><p>​        在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接 口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 </p><p>实现格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123;</span><br><span class="line"><span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">// 重写接口中默认方法【不重名时可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象方法</strong></p><p> 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</p><p> <strong>默认方法</strong> </p><p>接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 </p><p> <strong>静态方法</strong></p><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。  </p><p> <strong>优先级的问题</strong> </p><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执 行父类的成员方法。 </p><h2 id="1-5-接口的多继承"><a href="#1-5-接口的多继承" class="headerlink" title="1.5 接口的多继承"></a>1.5 接口的多继承</h2><p> 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继 承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次。</strong> </p><h2 id="1-6-其他成员变量"><a href="#1-6-其他成员变量" class="headerlink" title="1.6 其他成员变量"></a>1.6 其他成员变量</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 </li><li>接口中，没有构造方法，不能创建对象。 </li><li>接口中，没有静态代码块。  </li></ul><h1 id="第四章-多态"><a href="#第四章-多态" class="headerlink" title="第四章 多态"></a>第四章 多态</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><strong>引入</strong></p><p> 多态是继封装、继承之后，面向对象的第三大特性。  </p><p><strong>定义</strong></p><p><strong>多态：</strong> 是指同一行为，具有多个不同表现形式。</p><p><strong>前提</strong></p><ol><li>继承或者实现【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li>父类引用指向子类对象【格式体现】 </li></ol><h2 id="4-2-多态的体现"><a href="#4-2-多态的体现" class="headerlink" title="4.2 多态的体现"></a>4.2 多态的体现</h2><p><strong>多态体现的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象；</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法。  </p><h2 id="4-3-多态的好处"><a href="#4-3-多态的好处" class="headerlink" title="4.3 多态的好处"></a>4.3 多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利 </p><h2 id="4-4-引用类型转换"><a href="#4-4-引用类型转换" class="headerlink" title="4.4 引用类型转换"></a>4.4 引用类型转换</h2><p> <strong>多态的转型分为向上转型与向下转型两种：</strong>  </p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><ul><li><strong>向上转型</strong> ： ：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 </li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转型的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 </li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:Cat c =(Cat) a;</span><br></pre></td></tr></table></figure><h3 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h3><p> 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥 有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子 类特有的方法，必须做向下转型 </p><h3 id="转型异常"><a href="#转型异常" class="headerlink" title="转型异常"></a>转型异常</h3><p> Java提供了 instanceof 关键字，给引用变量做类型的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">如果变量属于该数据类型，返回<span class="keyword">true</span>。</span><br><span class="line">如果变量不属于该数据类型，返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h1 id="第五章-final关键字"><a href="#第五章-final关键字" class="headerlink" title="第五章 final关键字"></a>第五章 final关键字</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>子类可以在父类的基础上改写父类内容，为了避免这种随意改写的情况，Java提供了 final 关键字， 用于修饰不可改变内容。 </p><ul><li><strong>final</strong> ：不可改变，用于修饰类，方法和变量<ul><li>类：被修饰的类，不能被继承。 </li><li>方法：被修饰的方法，不能被重写。 </li><li>变量：被修饰的变量，不能被重新赋值。 </li></ul></li></ul><h2 id="5-2-使用方式"><a href="#5-2-使用方式" class="headerlink" title="5.2 使用方式"></a>5.2 使用方式</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a><strong>修饰类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询API发现像 public final class String 、 public final class Math 、 public final class Scanner 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 </p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a><strong>修饰方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重写被 final 修饰的方法，编译时就会报错 </p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><ol><li><p><strong>局部变量—-基本类型</strong></p><p> 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改 </p></li><li><p><strong>局部变量—-引用类型</strong></p><p> 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的 修改，。</p></li><li><p><strong>成员变量</strong></p><p>成员变量涉及到初始化的问题，初始化方式有两种，只能二选一 </p></li></ol><ul><li>显示初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String USERNAME = <span class="string">"张三"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String USERNAME ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.USERNAME = username;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章-权限修饰符"><a href="#第六章-权限修饰符" class="headerlink" title="第六章 权限修饰符"></a>第六章 权限修饰符</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p> 在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， </p><ul><li>public：公共的。 </li><li>protected：受保护的 </li><li>default（什么都不写）：默认的 </li><li>private：私有的 </li></ul><h2 id="6-2-不同权限的访问能力"><a href="#6-2-不同权限的访问能力" class="headerlink" title="6.2 不同权限的访问能力"></a>6.2 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default(空的)</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>同一包中</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>不同包的子类</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>不同包的无关类</td><td>✔</td><td></td><td></td><td></td></tr></tbody></table><p> 可见，public具有最大权限。private则是最小权限 。</p><p>建议</p><ul><li>成员变量使用 private ，隐藏细节。 </li><li>构造方法使用 public ，方便创建对象。 </li><li>成员方法使用 public ，方便调用方法。 </li></ul><h1 id="第七章-内部类"><a href="#第七章-内部类" class="headerlink" title="第七章 内部类"></a>第七章 内部类</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><h3 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a><strong>什么是内部类</strong></h3><p> 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h3><p> 成员内部类 ：定义在类中方法外的类。  </p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine </p><h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>外部类要访问内部类的成员，必须要建立内部类的对象。 </li></ul><p>创建内部类对象格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类型().<span class="keyword">new</span> 内部类型()；</span><br></pre></td></tr></table></figure><h2 id="7-2-匿名内部类"><a href="#7-2-匿名内部类" class="headerlink" title="7.2 匿名内部类"></a>7.2 匿名内部类</h2><ul><li><strong>匿名内部类</strong> ： 是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了 </li></ul><p><strong>前提</strong></p><p> 匿名内部类必须继承一个父类或者实现一个父接口。 </p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line"><span class="comment">// 方法重写</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础(三) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（二）</title>
      <link href="/2020/01/26/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/26/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在复习的Java基础的过程中采用写博客的方法，更有助于记忆的吸收，本篇博客总结了面向对象的思想，封装，还有常用API中Scanner类，Random类，ArrayList类，String类等，继续加油吧少年！</p>   <a id="more"></a><h1 id="第1章-面向对象思想"><a href="#第1章-面向对象思想" class="headerlink" title="第1章 面向对象思想"></a>第1章 面向对象思想</h1><h2 id="1-1面向对象思想的概述"><a href="#1-1面向对象思想的概述" class="headerlink" title="1.1面向对象思想的概述"></a>1.1面向对象思想的概述</h2><p><strong>概述</strong></p><p>​        Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计，开发计算机程序。这里的对象泛指现实中一切的事物，每种事物都具备自己的属性和行为。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><p><strong>区别</strong></p><ul><li>面向过程：强调步骤</li><li>面向对象： 强调对象</li></ul><p><strong>特点</strong></p><p>​        面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。面向对象的语言中，包含三大基本特征，即封装、继承、多态。</p><h2 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h2><p><strong>什么是类</strong></p><ul><li><strong>类：</strong>    是一组相关属性和行为的集合。</li><li><strong>属性：</strong>就是该事物的状态信息</li><li><strong>行为：</strong> 就是该事物能做什么</li></ul><p><strong>什么是对象</strong></p><ul><li><strong>对象：</strong>是一类事物的具体表现。对象是类的一个实例，必然具备该类事物的属性和行为。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是对一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><h2 id="1-3类的定义"><a href="#1-3类的定义" class="headerlink" title="1.3类的定义"></a>1.3类的定义</h2><p><strong>类的定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>定义类：</strong> 就是定义类的成员，包括成员变量和成员方法。</li><li><strong>成员变量：</strong> 在类中，方法外。</li><li><strong>成员方法：</strong> 和以前定义方法是一样的</li></ul><h2 id="1-4-对象的使用"><a href="#1-4-对象的使用" class="headerlink" title="1.4 对象的使用"></a>1.4 对象的使用</h2><p><strong>对象的使用格式</strong></p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名（）；</span><br></pre></td></tr></table></figure><p>使用对象访问类中的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure><h2 id="1-5成员变量和局部变量区别"><a href="#1-5成员变量和局部变量区别" class="headerlink" title="1.5成员变量和局部变量区别"></a>1.5成员变量和局部变量区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">String name;<span class="comment">//成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类中的位置不同</p><ul><li>成员变量：类中，方法外。</li><li>局部变量：方法中。</li></ul></li><li><p>作用的范围不一样</p><ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li><p>初始化默认值</p><ul><li>成员变量：有默认值</li><li>局部变量：没有默认值。必须先定义后赋值，在使用。</li></ul></li><li><p>在内存中的位置不同</p><ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li><p>生命周期不同</p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着调用的方法完毕而消失</li></ul></li></ul><h1 id="第2章-封装"><a href="#第2章-封装" class="headerlink" title="第2章 封装"></a>第2章 封装</h1><h2 id="2-1-封装概述"><a href="#2-1-封装概述" class="headerlink" title="2.1 封装概述"></a>2.1 封装概述</h2><p><strong>概述</strong></p><p>​        封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><p><strong>原则</strong></p><p>​        将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问</p><h2 id="2-2-封装的步骤"><a href="#2-2-封装的步骤" class="headerlink" title="2.2 封装的步骤"></a>2.2 封装的步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.使用 <span class="keyword">private</span> 关键字来修饰成员变量</span><br><span class="line"><span class="number">2</span>.对需要访问的成员变量，提供对应的get和set方法。</span><br></pre></td></tr></table></figure><h2 id="2-3-封装的操作—-private关键字"><a href="#2-3-封装的操作—-private关键字" class="headerlink" title="2.3 封装的操作—-private关键字"></a>2.3 封装的操作—-private关键字</h2><p><strong>private的含义</strong></p><ol><li>private是一个权限修饰符，代表最小权限</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只能在本类中使用</li></ol><p><strong>private的使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> ing age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-封装优化1—-this关键字"><a href="#2-4-封装优化1—-this关键字" class="headerlink" title="2.4 封装优化1—-this关键字"></a>2.4 封装优化1—-this关键字</h2><p><strong>this的含义</strong></p><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用</p><p>记住：方法被哪个对象调用，this就代表哪个对象，即谁在调用，this就代表谁</p><p><strong>this使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><h2 id="2-5-封装优化2—-构造方法"><a href="#2-5-封装优化2—-构造方法" class="headerlink" title="2.5 封装优化2—-构造方法"></a>2.5 封装优化2—-构造方法</h2><p>当一个对象被创建的时候，构建方法用来初始化该对象，给对象的成员变量赋值初始值</p><p><strong>构造方法的定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line">  <span class="comment">//方法名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name , <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>如果你不提供构造方法，系统会给出无参数构造方法。</li><li>如果你提供了构造方法，系统将不在提供无参数的构造方法</li><li>构造方法可以重载，既可以定义参数，也可以不定义参数</li></ol><h2 id="2-6-标准代码—–JavaBean"><a href="#2-6-标准代码—–JavaBean" class="headerlink" title="2.6 标准代码—–JavaBean"></a>2.6 标准代码—–JavaBean</h2><p>JavaBean是Java语言编写类的一种标准规范。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">//无参构造方法【必须】</span></span><br><span class="line"><span class="comment">//有参构造方法【建议】</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="comment">//getXxx()</span></span><br><span class="line"><span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第3章-Scanner类"><a href="#第3章-Scanner类" class="headerlink" title="第3章 Scanner类"></a>第3章 Scanner类</h1><h2 id="2-1-什么是Scanner类"><a href="#2-1-什么是Scanner类" class="headerlink" title="2.1 什么是Scanner类"></a>2.1 什么是Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in)</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure><h2 id="2-2-引用类型使用步骤"><a href="#2-2-引用类型使用步骤" class="headerlink" title="2.2 引用类型使用步骤"></a>2.2 引用类型使用步骤</h2><p><strong>创建对象</strong></p><p>使用该类的构造方法，创建一个该类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = <span class="keyword">new</span> 数据类型(参数列表);</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><p>调用该类的成员方法，完成指定功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.方法名()</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = sc.nextInt();</span><br></pre></td></tr></table></figure><h2 id="2-3-匿名对象"><a href="#2-3-匿名对象" class="headerlink" title="2.3 匿名对象"></a>2.3 匿名对象</h2><p><strong>概念</strong></p><p> 创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p><p>匿名对象：没有变量名的对象</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li><p>创建匿名对象直接调用方法，没有变量名。</p></li><li><p>一旦调用两次方法，就是创建了两个对象，造成浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line"><span class="keyword">new</span> Scanner(System.in).nextInt();</span><br></pre></td></tr></table></figure><p>一个匿名对象，只能使用一次</p><p>3.匿名对象可以作为方法的参数和返回值</p></li></ol><h1 id="第3章-Random类"><a href="#第3章-Random类" class="headerlink" title="第3章 Random类"></a>第3章 Random类</h1><h2 id="3-1-什么是Random类"><a href="#3-1-什么是Random类" class="headerlink" title="3.1 什么是Random类"></a>3.1 什么是Random类</h2><p>此类的实例用于生成随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br></pre></td></tr></table></figure><h2 id="3-2-Random使用步骤"><a href="#3-2-Random使用步骤" class="headerlink" title="3.2 Random使用步骤"></a>3.2 Random使用步骤</h2><p><strong>查看构造方法</strong></p><ul><li>public Random()：创建一个新的随机生成器</li></ul><p><strong>查看成员方法</strong></p><ul><li>public int nextInt(int n)：返回一个伪随机数，范围在0（包括）和 n（不包括）之间的int 值</li></ul><h1 id="第四章-ArrayList类"><a href="#第四章-ArrayList类" class="headerlink" title="第四章 ArrayList类"></a>第四章 ArrayList类</h1><h2 id="4-2-什么是ArrayList类"><a href="#4-2-什么是ArrayList类" class="headerlink" title="4.2 什么是ArrayList类"></a>4.2 什么是ArrayList类</h2><p>java.util.ArrayList是大小可变的数组实现，存储在内的数据称为元素，ArrayList中可不断添加元素，其大小也自动增长。</p><h2 id="4-3-ArrayList使用步骤"><a href="#4-3-ArrayList使用步骤" class="headerlink" title="4.3 ArrayList使用步骤"></a>4.3 ArrayList使用步骤</h2><p><strong>查看类</strong></p><p>java.util.ArrayList&lt; E &gt;: &lt; E &gt;表示一种泛型，使用一种引用数据类型将其替换即可</p><p><strong>查看构造方法</strong></p><p>public ArrayList()：构造一个内容为空的集合</p><p><strong>基本格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>查看成员方法</strong></p><p>public boolean add(E e)：将指定的元素添加到集合的尾部</p><p>在构造ArrayList对象时 &lt; E &gt;指定了什么数据类型，那么add（E e）方法中，只能添加什么类型的对象</p><h2 id="4-4-常用方法和遍历"><a href="#4-4-常用方法和遍历" class="headerlink" title="4.4 常用方法和遍历"></a>4.4 常用方法和遍历</h2><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span><span class="comment">//将指定元素添加到此集合的尾部</span></span><span class="function"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>)<span class="comment">//移除此集合中指定位置上的元素。返回被删除的元素</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回此集合中指定位置上的元素。返回获取的元素</span></span><span class="function"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>()<span class="comment">//返回此集合中的元素数</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><h2 id="4-5-如何存储基本数据类型"><a href="#4-5-如何存储基本数据类型" class="headerlink" title="4.5 如何存储基本数据类型"></a>4.5 如何存储基本数据类型</h2><p> ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似  不能写，但是存储基本数据类型对应的 包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： </p><table><thead><tr><th>基本数据类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h1 id="第五章-String类"><a href="#第五章-String类" class="headerlink" title="第五章 String类"></a>第五章 String类</h1><h2 id="1-1-String类概述"><a href="#1-1-String类概述" class="headerlink" title="1.1 String类概述"></a>1.1 String类概述</h2><p><strong>概述</strong></p><p>String类代表字符串。Java程序中所有的字符串文字（例如“abc”）都可以被看作是实现此类的实例。类String中包括用于检查各个字符串的方法。</p><p><strong>特点</strong></p><ol><li><p>字符串不变：字符串的值在创建后就不能被更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String S1 = <span class="string">"abc"</span>;</span><br><span class="line">S1 += <span class="string">"d"</span>;</span><br><span class="line">System.out.println(S1);<span class="comment">//"abcd"</span></span><br><span class="line"><span class="comment">//内存中有"abc"和"abcd"两个对象，S1从指向"abc",改变指向"abcd"</span></span><br></pre></td></tr></table></figure></li><li><p>因为String对象是不可变的，所有它可以共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//内存中有"abc"对象被创建，同时被a和b共享</span></span><br></pre></td></tr></table></figure></li><li><p>“abc” 等效于 char[] data = {‘a’,’b’,’c’}.</p></li></ol><h2 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h2><ul><li><strong>查看构造方法</strong><ul><li>public String()：初始化创建的String对象</li><li>public String(char[] value)：通过当前的字符串数组来构造新的String</li><li>public String(byte[] bytes)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符数组构造</span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字节数组构造</span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p><strong>判断功能的方法</strong></p><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span><span class="comment">//将此字符串与指定的对象进行比较</span></span><span class="function"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(<span class="keyword">String</span> anotherString)</span><span class="comment">//将此字符串与指定对象进行比较，忽略大小写</span></span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><p>–Object是对象的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法 </p><p><strong>获取功能的方法</strong></p><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="comment">//返回此字符串的长度</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">concat</span>(<span class="keyword">String</span> <span class="built_in">str</span>)<span class="comment">//将指定的字符串连接到该字符串的结尾</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回指定索引处的char值。</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> indexOf(<span class="keyword">String</span> <span class="built_in">str</span>)<span class="comment">//返回字符串第一次出现在该字符串的索引</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span><span class="comment">//返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><span class="function"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">//返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</span></span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><p><strong>转换功能的方法</strong></p><ul><li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray ()<span class="comment">//将此字符串转换为新的字符数组。</span>&lt;!--￼<span class="number">30</span>--&gt;</code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span><span class="comment">//将与target匹配的字符串使用replacement字符串替换。</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**分割功能的方法**</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">String</span>[] <span class="built_in">split</span>(<span class="keyword">String</span> regex)<span class="comment">//将此字符串按照给定的regex（规则）拆分为字符串数组。</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><h1 id="第六章-static关键字"><a href="#第六章-static关键字" class="headerlink" title="第六章 static关键字"></a>第六章 static关键字</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h2><p>​         static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 </p><h2 id="2-2-定义和使用格式"><a href="#2-2-定义和使用格式" class="headerlink" title="2.2 定义和使用格式"></a>2.2 定义和使用格式</h2><p><strong>类变量</strong></p><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 </p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> id；</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong></p><p>当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要 创建类的对象。调用方式非常简单。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"num:"</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态方法调用的注意事项： <ul><li>静态方法可以直接访问类变量和静态方法。 </li><li>静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法 </li><li>静态方法中，不能使用this关键字 </li></ul></li></ul><p>静态方法只能访问静态成员</p><p><strong>调用格式</strong></p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名；</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数)；</span><br></pre></td></tr></table></figure><h2 id="2-3-static-修饰的内容："><a href="#2-3-static-修饰的内容：" class="headerlink" title="2.3 static 修饰的内容："></a>2.3 static 修饰的内容：</h2><ul><li>是随着类的加载而加载的，且只加载一次。 </li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 </li><li>它优先于对象存在，所以，可以被所有对象共享。  </li></ul><h2 id="2-4-静态代码块"><a href="#2-4-静态代码块" class="headerlink" title="2.4 静态代码块"></a>2.4 静态代码块</h2><ul><li>静态代码块：定义在成员位置，使用static修饰的代码块{ … }。 <ul><li>位置：类中方法外。 </li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 </li></ul></li></ul><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// 执行语句</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：</p><p> static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。  </p><h1 id="第七章-Arrays类"><a href="#第七章-Arrays类" class="headerlink" title="第七章 Arrays类"></a>第七章 Arrays类</h1><h2 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h2><p> Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法。  </p><h2 id="7-2操作数组的方法"><a href="#7-2操作数组的方法" class="headerlink" title="7.2操作数组的方法"></a>7.2操作数组的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span><span class="comment">//返回指定数组内容的字符串表示形式。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span><span class="comment">//对指定的 int 型数组按数字升序进行排序。</span></span></span><br></pre></td></tr></table></figure><h1 id="第八章-Math类"><a href="#第八章-Math类" class="headerlink" title="第八章 Math类"></a>第八章 Math类</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p> Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具 类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。  </p><h2 id="8-2基本运算方法"><a href="#8-2基本运算方法" class="headerlink" title="8.2基本运算方法"></a>8.2基本运算方法</h2><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回 double 值的绝对值。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.abs(‐<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回大于等于参数的最小的整数。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.ceil(‐<span class="number">3.3</span>); <span class="comment">//d2的值为 ‐3.0</span></span><br><span class="line"><span class="built_in">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回小于等于参数最大的整数。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.floor(‐<span class="number">3.3</span>); <span class="comment">//d2的值为‐4.0</span></span><br><span class="line"><span class="built_in">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回最接近参数的 long。(相当于四舍五入方法)</span></span><span class="function"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">long</span> d1 = Math.<span class="keyword">round</span>(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">long</span> d2 = Math.<span class="keyword">round</span>(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础（二） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2020/01/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习Java基础，刚刚好也做下笔记，本文介绍什么是Java，Java语言的开发环境，基本的数据类型有哪些，介绍了方法的概述，定义，与调用方法的三种形式，还有三种循环，数组等，再接再厉不服努力加油！！！</p>   <a id="more"></a><h2 id="1-1计算机基础知识"><a href="#1-1计算机基础知识" class="headerlink" title="1.1计算机基础知识"></a>1.1计算机基础知识</h2><p>​        <strong>字节</strong>： 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性， 我们可以查看文件的字节大小。 </p><p> 8 bit = 1 B ，1024 B =1 KB ，1024 KB =1 MB ，1024 MB =1 GB ，1024 GB = 1 TB </p><p>​        <strong>常用DOS命令</strong>：</p><table><thead><tr><th>命令</th><th>操作符号</th></tr></thead><tbody><tr><td>盘符切换命令</td><td>D：</td></tr><tr><td>查看当前文件夹</td><td>dir</td></tr><tr><td>进入文件夹命令</td><td>cd 文件夹名</td></tr><tr><td>退出文件夹命令</td><td>cd..</td></tr><tr><td>退出磁盘根目录</td><td>cd\</td></tr><tr><td>清屏</td><td>cls</td></tr></tbody></table><h1 id="第二章Java语言开发环境"><a href="#第二章Java语言开发环境" class="headerlink" title="第二章Java语言开发环境"></a>第二章Java语言开发环境</h1><h2 id="2-1-Java虚拟机–JVM"><a href="#2-1-Java虚拟机–JVM" class="headerlink" title="2.1  Java虚拟机–JVM"></a>2.1  Java虚拟机–JVM</h2><p>​        <strong>JVM</strong>： ：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 </p><h2 id="2-2-JRE和JDK"><a href="#2-2-JRE和JDK" class="headerlink" title="2.2 JRE和JDK"></a>2.2 JRE和JDK</h2><pre><code>**· JRE**： 是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 </code></pre><p>​    <strong>· JDK</strong>：  是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 </p><p>​    三者关系： JDK&gt;JRE&gt;JVM</p><h1 id="第三章程序说明"><a href="#第三章程序说明" class="headerlink" title="第三章程序说明"></a>第三章程序说明</h1><h2 id="3-1编译和运行是两回事"><a href="#3-1编译和运行是两回事" class="headerlink" title="3.1编译和运行是两回事"></a>3.1编译和运行是两回事</h2><p>​            <strong>·  编译：</strong>是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们 所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。 </p><p>​            <strong>·运行</strong>：是指将 class文件 交给JVM去运行，此时JVM就会去执行我们编写的程序了。</p><h2 id="3-2关于main方法"><a href="#3-2关于main方法" class="headerlink" title="3.2关于main方法"></a>3.2关于main方法</h2><p>​         <strong>main方法</strong>：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多 少程序，JVM在运行的时候，都会从main方法这里开始执行。</p><h2 id="3-3关键字keywords"><a href="#3-3关键字keywords" class="headerlink" title="3.3关键字keywords"></a>3.3关键字keywords</h2><p>​         <strong>关键字</strong>：是指在程序中，Java已经定义好的单词，具有特殊含义。 HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母，notepad++中颜色特殊。   </p><h2 id="3-4-标识符"><a href="#3-4-标识符" class="headerlink" title="3.4 标识符"></a>3.4 标识符</h2><p> <strong>标识符：</strong>是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 </p><p> <strong>命名规则：</strong> <strong>硬性要求</strong> </p><p>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字 </p><p> <strong>命名规范： 软性建议</strong> </p><p>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。 </p><h1 id="第四章变量和数据类型"><a href="#第四章变量和数据类型" class="headerlink" title="第四章变量和数据类型"></a>第四章变量和数据类型</h1><h2 id="5-1数据类型"><a href="#5-1数据类型" class="headerlink" title="5.1数据类型"></a>5.1数据类型</h2><h3 id="Java的数据类型分为两大类"><a href="#Java的数据类型分为两大类" class="headerlink" title="Java的数据类型分为两大类"></a>Java的数据类型分为两大类</h3><p>​    <strong>基本数据类型：</strong>包括 整数、浮点数、字符、布尔。</p><p>​    <strong>引用数据类型：</strong>包括 类、数组、接口。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="四类八种基本数据类型"><a href="#四类八种基本数据类型" class="headerlink" title="四类八种基本数据类型"></a>四类八种基本数据类型</h4><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1个字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2个字节</td><td>-32768~32767</td></tr><tr><td>整型</td><td>int</td><td>4个字节</td><td>-231次方~2的31次方-1</td></tr><tr><td>长整型</td><td>long</td><td>8个字节</td><td>-2的63次方~2的63次方-1</td></tr><tr><td>单精度浮点数</td><td>folat</td><td>4个字节</td><td>1.4013E-45~3.4028E+38</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8个字节</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字节型</td><td>char</td><td>2个字节</td><td>0-65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>1个字节</td><td>true，false</td></tr></tbody></table><p>Java中的默认类型： 整数类型是int，浮点类型是double</p><h2 id="5-2变量的定义"><a href="#5-2变量的定义" class="headerlink" title="5.2变量的定义"></a>5.2变量的定义</h2><p> <strong>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</strong> </p><p>变量定义的格式包括三个要素： 数据类型、变量名、数据值。</p><p><strong>格式</strong>： <strong>数据类型 变量名 = 数据值；</strong></p><h2 id="5-3注意事项"><a href="#5-3注意事项" class="headerlink" title="5.3注意事项"></a>5.3注意事项</h2><p><strong>变量名称：在同一个大括号范围内，变量的名字不可以相同</strong></p><p><strong>变量赋值：定义是变量，不赋值不能使用。</strong></p><h1 id="第五章-方法"><a href="#第五章-方法" class="headerlink" title="第五章 方法"></a>第五章 方法</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p> 我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。</p><p>​         <strong>方法：</strong>就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 </p><h2 id="5-2方法的定义"><a href="#5-2方法的定义" class="headerlink" title="5.2方法的定义"></a>5.2方法的定义</h2><p> <strong>定义格式：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">代码...</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li>修饰符：public static</li><li>返回值类型：表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</li><li>参数列表：方法在运行过程中未知数据，调用者调用方法时传递</li><li>return：将方法执行后的结果带给调用者，方法执行到return，整体方法运行结束</li></ul><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一个方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3方法的调用"><a href="#5-3方法的调用" class="headerlink" title="5.3方法的调用"></a>5.3方法的调用</h2><p>​     <strong>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在 主方法中，直接写要调用的方法名字就可以调用了</strong>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用定义的方法method</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法，被main方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"自己定义的方法，需要被main调用运行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4调用方法的三种形式"><a href="#5-4调用方法的三种形式" class="headerlink" title="5.4调用方法的三种形式"></a>5.4调用方法的三种形式</h2><ul><li><p><strong>直接调用：</strong>直接写方法名调用</p></li><li><pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{    print();}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{    System.out.println(<span class="string">"方法被调用"</span>);}&lt;!--￼<span class="number">3</span>--&gt;</code></pre></li><li><p><strong>输出语句调用：</strong> 在输出语句中调用方法， System.out.println(方法名()) 。 </p></li></ul><h2 id="5-5方法重载"><a href="#5-5方法重载" class="headerlink" title="5.5方法重载"></a>5.5方法重载</h2><ul><li><p><strong>方法重载：</strong> 指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。  </p></li><li><p>参数列表：个数不同，数据类型不同，顺序不同。 </p></li><li><p>重载方法调用：JVM通过方法的参数列表，调用不同的方法。 </p></li><li><p>如：</p></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a)</span></span>{}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span></span>{}&lt;!--￼<span class="number">4</span>--&gt;</code></pre></li></ul><h2 id="6-2循环语句–while"><a href="#6-2循环语句–while" class="headerlink" title="6.2循环语句–while"></a>6.2循环语句–while</h2><p> <strong>while循环语句格式：</strong>  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(布尔表达式②)</span></span>&#123;</span><br><span class="line">循环体③</span><br><span class="line">步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3循环语句–do…while"><a href="#6-3循环语句–do…while" class="headerlink" title="6.3循环语句–do…while"></a>6.3循环语句–do…while</h2><p> <strong>do…while循环格式</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体③</span><br><span class="line">步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><h2 id="6-4循环语句的区别"><a href="#6-4循环语句的区别" class="headerlink" title="6.4循环语句的区别"></a>6.4循环语句的区别</h2><p> <strong>for 和 while 的小区别：</strong> </p><p>​        控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。</p><p>​         在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 </p><h2 id="6-5跳出语句"><a href="#6-5跳出语句" class="headerlink" title="6.5跳出语句"></a>6.5跳出语句</h2><p><strong>break</strong></p><p>​    <strong>使用场景：终止switch或者循环</strong></p><p>​                 在选择结构switch语句中 </p><p>​                 在循环语句中 </p><p>​                 离开使用场景的存在是没有意义的 </p><p><strong>continue</strong></p><p>​        <strong>使用场景：结束本次循环，继续下一次的循环</strong></p><h1 id="第7章数组"><a href="#第7章数组" class="headerlink" title="第7章数组"></a>第7章数组</h1><h2 id="7-1数组定义和访问"><a href="#7-1数组定义和访问" class="headerlink" title="7.1数组定义和访问"></a>7.1数组定义和访问</h2><h3 id="7-1-1容器概述"><a href="#7-1-1容器概述" class="headerlink" title="7.1.1容器概述"></a>7.1.1容器概述</h3><p><strong>容器概念</strong>：</p><p>​        <strong>容器：</strong>是将多个数据储存到一起，每个数据称为该容器的元素。</p><h3 id="7-1-2数组的概念"><a href="#7-1-2数组的概念" class="headerlink" title="7.1.2数组的概念"></a>7.1.2数组的概念</h3><p> <strong>数组概念：</strong> 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</p><h3 id="7-1-3数组的定义"><a href="#7-1-3数组的定义" class="headerlink" title="7.1.3数组的定义"></a>7.1.3数组的定义</h3><p><strong>方式一</strong></p><p>​        <strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br></pre></td></tr></table></figure><ul><li><strong>数组定义格式详解：</strong><ul><li>数组存储的数据类型：创建的数组可以储存什么数据类型。</li><li>[]：表示数组</li><li>数组名字：为定义的数据起一个变量名，满足标识符规范，可以使用名字操作数组</li><li>new：关键字，创建数组的关键字</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。 </li><li><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong> </li></ul></li></ul><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><p>​        <strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>...&#125;;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> intp[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>方式三</strong></p><p>​        <strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>...&#125;;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-1-4-数组的访问"><a href="#7-1-4-数组的访问" class="headerlink" title="7.1.4 数组的访问"></a>7.1.4 数组的访问</h3><ul><li><p><strong>索引：</strong> 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为<strong>数组索引 (index)</strong>，可以通过数组的索引访问到数组中的元素。 </p></li><li><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure></li><li><p><strong>数组的长度：</strong> 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： <strong>数组名.length</strong> </p></li></ul><h2 id="7-2数组原理内存"><a href="#7-2数组原理内存" class="headerlink" title="7.2数组原理内存"></a>7.2数组原理内存</h2><h3 id="7-2-1内存概述"><a href="#7-2-1内存概述" class="headerlink" title="7.2.1内存概述"></a>7.2.1内存概述</h3><p>​         内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 </p><h3 id="7-2-2Java虚拟机的内存划分"><a href="#7-2-2Java虚拟机的内存划分" class="headerlink" title="7.2.2Java虚拟机的内存划分"></a>7.2.2Java虚拟机的内存划分</h3><p>​         为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 </p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行。</td></tr></tbody></table><h3 id="7-2-3数组的常见操作"><a href="#7-2-3数组的常见操作" class="headerlink" title="7.2.3数组的常见操作"></a>7.2.3数组的常见操作</h3><ul><li><strong>数据越界异常</strong></li><li><strong>数组空指针异常</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础（一） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的一年新的开始！</title>
      <link href="/2020/01/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2020/01/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新的一年就要来啦！！请你一定不要停下来成为你想成为的人。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
