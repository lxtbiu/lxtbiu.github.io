<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>位运算--加减乘除、大小比较、两数交换</title>
      <link href="/2020/04/14/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E3%80%81%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E3%80%81%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2/"/>
      <url>/2020/04/14/%E4%BD%8D%E8%BF%90%E7%AE%97-%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E3%80%81%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83%E3%80%81%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 本篇博客介绍了如何用二进制位运算来进行加减乘除，交换，比大小等。</p><a id="more"></a><h1 id="1-位运算—加法"><a href="#1-位运算—加法" class="headerlink" title="1. 位运算—加法"></a>1. 位运算—加法</h1><p><strong>举个例子</strong>：</p><p>8+9=17，可以转换成10+7，即：二者相加不考虑进位的值，和二者相加只考虑进位的值相加。我们再通过二进制来直观的看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">1000</span> (<span class="number">8</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">1001</span> (<span class="number">9</span>)</span><br><span class="line"><span class="number">0001</span> <span class="number">0001</span> (<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p> <strong>思路：</strong></p><p>首先我们看，直接二进制相加的结果，0+0=0,1+0=1,1+1=10。好像能看出点什么。<strong>前两个的运算规则复合“异或运算”，而后者则复合与运算并左移1位。</strong></p><p>到现在思路就清楚了：a^b的结果是不考虑进位的结果，而a&amp;b&lt;&lt;1是只考虑进位的结果。把二者相加即可。如果相加后，可能还存在进位，那就让这两个数字继续相加，一直到进位为0为止。这里使用递归去实现，感兴趣的可以用循环实现，性能比递归要高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 得到原位和</span></span><br><span class="line">       <span class="keyword">int</span> xor = a ^ b;</span><br><span class="line">       <span class="comment">// 得到进位和</span></span><br><span class="line">       <span class="keyword">int</span> forWoad = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> forWoad == <span class="number">0</span> ? xor : add(xor, forWoad);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="2-位运算—取负数"><a href="#2-位运算—取负数" class="headerlink" title="2. 位运算—取负数"></a>2. 位运算—取负数</h1><p>计算机中的负数实现，是将正数按位取反获取反码，之后+1获得补码，这个结果就是某个正数所对应的负数。 </p><p> 负数的实现其实还是比较简单的，按位取反之后+1即可 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">negative</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> add(~num, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="3-位运算—减法"><a href="#3-位运算—减法" class="headerlink" title="3. 位运算—减法"></a>3. 位运算—减法</h1><p>实现了负数之后，我们第一步实现的加法就可以和负数进行运算了，而减法也就变得简单起来。</p><p>减法的实现如4-2等价于4+(-2)，我们直接使用加法和负数就可以实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> add(a, negative(b));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="4-位运算—绝对值"><a href="#4-位运算—绝对值" class="headerlink" title="4. 位运算—绝对值"></a>4. 位运算—绝对值</h1><p>接下来要实现乘法和除法。乘法和除法可能会有正数和负数相互计算的情况，因此我们实现乘除之前，需要先实现绝对值计算的功能，将运算数字转换成绝对值进行乘除，之后判断是否需要加上负号即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        num = minus(<span class="number">0</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-位运算—乘法"><a href="#5-位运算—乘法" class="headerlink" title="5. 位运算—乘法"></a>5. 位运算—乘法</h1><p>乘法的实现，如11*10，乘法的流程如下面所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">1011</span> （<span class="number">11</span>）</span><br><span class="line"><span class="number">0000</span> <span class="number">1010</span> （<span class="number">10</span>）</span><br><span class="line">================</span><br><span class="line"><span class="number">0001</span> <span class="number">0110</span> （<span class="number">1011</span>&lt;&lt;<span class="number">1</span>，相当于乘以<span class="number">0010</span>）</span><br><span class="line"><span class="number">0101</span> <span class="number">1000</span> （<span class="number">1011</span>&lt;&lt;<span class="number">3</span>，相当于乘以<span class="number">1000</span>）</span><br></pre></td></tr></table></figure><p>可以看到，二进制乘法的原理是：从乘数的低位到高位，遇到1并且这个1在乘数的右边起第i（i从0开始）位，那么就把被乘数左移i位得到temp_i，直到乘数中的1遍历完毕后，把根据各位1而得到的被乘数的左移值全部相加即得到乘法结果。</p><p>而至于存在负数的运算，可以先获取负数的个数，再将两个数字转换成绝对值计算，最后判断当负数是1个时，计算结果就是负数，其他情况则是正数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先获取负数的个数</span></span><br><span class="line">    <span class="keyword">int</span> negativeCount = negativeCount(a, b);</span><br><span class="line">    <span class="comment">// 负数转正数进行计算</span></span><br><span class="line">    a = abs(a);</span><br><span class="line">    b = abs(b);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 乘数为0则结束</span></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理乘数当前位</span></span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = add(res, a &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        i = add(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (negativeCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 转为负数</span></span><br><span class="line">        res = negative(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>negativeCount方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">negativeCount</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        count = add(count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        count = add(count, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乘法事实上有个简单的实现。乘法就是个连加的过程，如5*4就是4个5相加，这个虽然性能比较低，但是操作起来简单</p><h1 id="6-位运算—除法"><a href="#6-位运算—除法" class="headerlink" title="6. 位运算—除法"></a>6. 位运算—除法</h1><p>除法没有什么简单的二进制实现方案，实际计算机中的除法也是通过连减去计算的。a/b的意义就是求a可以由多少个b组成，因此除法可以求a能减去多少个b。至于负数的情况，和乘法相同，不再介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先获取负数的个数</span></span><br><span class="line">    <span class="keyword">int</span> negativeCount = negativeCount(a, b);</span><br><span class="line">    <span class="comment">// 负数转正数进行计算</span></span><br><span class="line">    a = abs(a);</span><br><span class="line">    b = abs(b);</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = add(sub(minus(a, b), b), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (negativeCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 转为负数</span></span><br><span class="line">        res = negative(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-位运算—取模"><a href="#7-位运算—取模" class="headerlink" title="7. 位运算—取模"></a>7. 位运算—取模</h1><p>取模<br>取模运算的思路和除法一样，也是个连减的过程，一直减到我们减不了为止，剩下的值就是我们要的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先获取负数的个数</span></span><br><span class="line">    <span class="keyword">int</span> negativeCount = negativeCount(a, b);</span><br><span class="line">    <span class="comment">// 负数转正数进行计算</span></span><br><span class="line">    a = abs(a);</span><br><span class="line">    b = abs(b);</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        res = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = sub(minus(a, b), b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (negativeCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 转为负数</span></span><br><span class="line">        res = negative(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-位运算—两数交换"><a href="#8-位运算—两数交换" class="headerlink" title="8. 位运算—两数交换"></a>8. 位运算—两数交换</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br></pre></td></tr></table></figure><h1 id="9-位运算—两数大小比较"><a href="#9-位运算—两数大小比较" class="headerlink" title="9. 位运算—两数大小比较"></a>9. 位运算—两数大小比较</h1><p>一切的运算在计算机中都是二进制，数字也是用二进制表示的，而二进制表示数字的时候，最高位是代表符号位，1是负数，0是正数，传统的int最高32位。因此我们只需要判断第32位的结果是0还是1就能判断谁大谁小。直接判断第32位肯定不现实，这里就需要使用到无符号右移运算符“&gt;&gt;&gt;”。举个简单的例子，下面这串二进制只需要无符号右移31位，就可以得到最高位的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="number">0010</span> <span class="number">1101</span> <span class="number">0100</span> <span class="number">1101</span> <span class="number">0001</span> <span class="number">0010</span> <span class="number">0011</span></span><br><span class="line">无符号右移<span class="number">31</span>位后</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure><p>结果显而易见，最高位降到了最低位，其余位全部变成了0，因此，只要结果是负数，那么进行 &gt;&gt;&gt;31 之后的结果转为十进制就是1，否则为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">     <span class="keyword">int</span> index = (a - b) &gt;&gt;&gt; <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p>这样，我们只需要判断index即可。</p><p>那么问题来了，题目要求是不允许判断，该怎么办呢？其实这里可以使用数组，下标为0的地方输出a&gt;=b，为1的地方输出a&lt;b。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> index = (a - b) &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        String[] arr = &#123;<span class="string">"a&gt;=b"</span>, <span class="string">"a&lt;b"</span>&#125;;</span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = (a - b) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    String[] arr = &#123;<span class="string">"a=b"</span>, <span class="string">"a&gt;b"</span>, <span class="string">"a&lt;b"</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(arr[diff]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = diff &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        System.out.println(arr[index + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构----树</title>
      <link href="/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2020/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本篇博客介绍了数据结构—–树结构的应用</strong></p> <a id="more"></a><h1 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h1><h2 id="1-1-为什么需要树这种结构"><a href="#1-1-为什么需要树这种结构" class="headerlink" title="1.1 为什么需要树这种结构"></a>1.1 为什么需要树这种结构</h2><ol><li><p><strong>数组存储方式的分析</strong></p><p><strong>优点：</strong>通过下标方式访问元素，速度快。<strong>对于有序数组</strong>，还可使用二分查找提高检索速度。<br><strong>缺点：</strong>如果要检索具体某个值，或者插入值(按一定顺序)<strong>会整体移动</strong>，效率较低   </p></li><li><p><strong>链式存储方式的分析</strong></p><p><strong>优点：</strong>在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。<br><strong>缺点：</strong>在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)   </p></li><li><p><strong>树存储方式的分析</strong></p><p>能提高数据<strong>存储，读取</strong>的效率, 比如利用 <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。  </p></li></ol><h2 id="1-2-二叉树的概念"><a href="#1-2-二叉树的概念" class="headerlink" title="1.2 二叉树的概念"></a>1.2 二叉树的概念</h2><ol><li>树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。</li><li>二叉树的子节点分为左节点和右节点。</li><li>如果该二叉树的<strong>所有叶子节点都在最后一层</strong>，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树  </li><li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。</li></ol><p><img src="D:%5Cblog%5Cpublic%5Cimages%5Cimage%5C1.png" alt="1"></p><h2 id="1-3-使用前序中序后序遍历二叉树"><a href="#1-3-使用前序中序后序遍历二叉树" class="headerlink" title="1.3 使用前序中序后序遍历二叉树"></a>1.3 使用前序中序后序遍历二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写前序遍历的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line"><span class="comment">//递归向左子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.preOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归向右子树前序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.preOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归向左子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出父结点</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//递归向右子树中序遍历</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.postOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.postOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-分别使用前序中序后序查找二叉树"><a href="#1-4-分别使用前序中序后序查找二叉树" class="headerlink" title="1.4 分别使用前序中序后序查找二叉树"></a>1.4 分别使用前序中序后序查找二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> no 需要查找的编号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果有则返回Node,没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">    <span class="comment">//比较当前结点是不是</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">    <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">    <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">    HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-二叉树-删除节点"><a href="#1-5-二叉树-删除节点" class="headerlink" title="1.5 二叉树-删除节点"></a>1.5 二叉树-删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//递归删除结点</span></span><br><span class="line">  <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">  <span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//思路</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="2、-顺序存储二叉树"><a href="#2、-顺序存储二叉树" class="headerlink" title="2、 顺序存储二叉树"></a>2、 顺序存储二叉树</h1><h2 id="2-1-顺序存储二叉树的概念"><a href="#2-1-顺序存储二叉树的概念" class="headerlink" title="2.1 顺序存储二叉树的概念"></a>2.1 顺序存储二叉树的概念</h2><p><strong>顺序存储二叉树的特点:</strong></p><ol><li>顺序二叉树通常只考虑完全二叉树</li><li>第n个元素的左子节点为 2 * n + 1 </li><li>第n个元素的右子节点为 2 * n + 2</li><li>第n个元素的父节点为 (n-1) / 2</li><li>n : 表示二叉树中的第几个元素</li></ol><h2 id="2-2-递归添加二叉树节点"><a href="#2-2-递归添加二叉树节点" class="headerlink" title="2.2 递归添加二叉树节点"></a>2.2 递归添加二叉树节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-顺序存储二叉树的前序遍历"><a href="#2-3-顺序存储二叉树的前序遍历" class="headerlink" title="2.3 顺序存储二叉树的前序遍历"></a>2.3 顺序存储二叉树的前序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 数组的下标 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line"><span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出当前这个元素</span></span><br><span class="line">System.out.println(arr[index]); </span><br><span class="line"><span class="comment">//向左递归遍历</span></span><br><span class="line"><span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向右递归遍历</span></span><br><span class="line"><span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、-赫夫曼树"><a href="#3、-赫夫曼树" class="headerlink" title="3、 赫夫曼树"></a>3、 赫夫曼树</h1><h2 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h2><ol><li><strong>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</strong></li><li><strong>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</strong></li></ol><h2 id="3-2-赫夫曼树几个重要概念"><a href="#3-2-赫夫曼树几个重要概念" class="headerlink" title="3.2 赫夫曼树几个重要概念"></a>3.2 赫夫曼树几个重要概念</h2><ol><li><strong>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</strong></li><li><strong>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</strong></li><li><strong>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树</strong></li><li><strong>WPL最小的就是赫夫曼树</strong></li></ol><p><strong>总而言之—-WPL最小的就是赫夫曼树，WPL：树的带权路径长度规定为所有叶子结点的带权路径长度之和</strong></p><h2 id="3-3赫夫曼树代码实现"><a href="#3-3赫夫曼树代码实现" class="headerlink" title="3.3赫夫曼树代码实现"></a>3.3赫夫曼树代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">huofumanSearch</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">        <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">        <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们处理的过程是一个循环的过程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排序 从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"nodes ="</span> + nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//(1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">            Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//(2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">            Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回哈夫曼树的root结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、二叉排序树"><a href="#4、二叉排序树" class="headerlink" title="4、二叉排序树"></a>4、二叉排序树</h1><ul><li><strong>使用数组</strong></li></ul><ol><li><strong>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢</strong></li><li><strong>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[示意图]</strong></li></ol><ul><li><strong>使用链式存储-链表不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。</strong></li></ul><ul><li><strong>使用二叉排序树</strong></li></ul><h2 id="4-1-二叉排序树介绍"><a href="#4-1-二叉排序树介绍" class="headerlink" title="4.1 二叉排序树介绍"></a>4.1 二叉排序树介绍</h2><p><strong>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</strong><br><strong>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</strong></p><h2 id="4-2-二叉排序树的创建和遍历"><a href="#4-2-二叉排序树的创建和遍历" class="headerlink" title="4.2 二叉排序树的创建和遍历"></a>4.2 二叉排序树的创建和遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加结点的方法</span></span><br><span class="line"><span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line"><span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归的向左子树添加</span></span><br><span class="line"><span class="keyword">this</span>.left.add(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//递归的向右子树添加</span></span><br><span class="line"><span class="keyword">this</span>.right.add(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-二叉排序树的删除"><a href="#4-3-二叉排序树的删除" class="headerlink" title="4.3 二叉排序树的删除"></a>4.3 二叉排序树的删除</h2><p><strong>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</strong></p><ol><li><strong>删除叶子节点</strong></li><li><strong>删除只有一颗子树的节点</strong></li><li><strong>删除有两颗子树的节点.</strong></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">Node targetNode = search(value);</span><br><span class="line"><span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line"><span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">root = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">Node parent = searchParent(value);</span><br><span class="line"><span class="comment">//如果要删除的结点是叶子结点</span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">parent.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是由子结点</span></span><br><span class="line">parent.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123; <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line"><span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">targetNode.value = minVal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line"><span class="comment">//如果要删除的结点有左子结点 </span></span><br><span class="line"><span class="keyword">if</span>(targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.left;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果要删除的结点有右子结点 </span></span><br><span class="line"><span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line"><span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">parent.left = targetNode.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">parent.right = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = targetNode.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、-平衡二叉树（AVL树）"><a href="#5、-平衡二叉树（AVL树）" class="headerlink" title="5、 平衡二叉树（AVL树）"></a>5、 平衡二叉树（AVL树）</h1><h2 id="5-1-基本介绍"><a href="#5-1-基本介绍" class="headerlink" title="5.1 基本介绍"></a>5.1 基本介绍</h2><ol><li><strong>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</strong></li><li><strong>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</strong></li></ol><h2 id="5-2-平衡二叉树左旋转"><a href="#5-2-平衡二叉树左旋转" class="headerlink" title="5.2 平衡二叉树左旋转"></a>5.2 平衡二叉树左旋转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"><span class="comment">//把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">newNode.left = left;</span><br><span class="line"><span class="comment">//把新的结点的右子树设置成带你过去结点的右子树的左子树</span></span><br><span class="line">newNode.right = right.left;</span><br><span class="line"><span class="comment">//把当前结点的值替换成右子结点的值</span></span><br><span class="line">value = right.value;</span><br><span class="line"><span class="comment">//把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">right = right.right;</span><br><span class="line"><span class="comment">//把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">left = newNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-平衡二叉树右旋转"><a href="#5-3-平衡二叉树右旋转" class="headerlink" title="5.3 平衡二叉树右旋转"></a>5.3 平衡二叉树右旋转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">newNode.right = right;</span><br><span class="line">newNode.left = left.right;</span><br><span class="line">value = left.value;</span><br><span class="line">left = left.left;</span><br><span class="line">right = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-平衡二叉树左右双旋转"><a href="#5-4-平衡二叉树左右双旋转" class="headerlink" title="5.4 平衡二叉树左右双旋转"></a>5.4 平衡二叉树左右双旋转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line"><span class="keyword">if</span>(rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line"><span class="comment">//先对右子结点进行右旋转</span></span><br><span class="line">right.rightRotate();</span><br><span class="line"><span class="comment">//然后在对当前结点进行左旋转</span></span><br><span class="line">leftRotate(); <span class="comment">//左旋转..</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行左旋转即可</span></span><br><span class="line">leftRotate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ; <span class="comment">//必须要!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line"><span class="keyword">if</span>(leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line"><span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line"><span class="comment">//先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">left.leftRotate();</span><br><span class="line"><span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//直接进行右旋转即可</span></span><br><span class="line">rightRotate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、二叉树与B树，B-树，B-树"><a href="#6、二叉树与B树，B-树，B-树" class="headerlink" title="6、二叉树与B树，B+树，B*树"></a>6、二叉树与B树，B+树，B*树</h1><h2 id="6-1-B树的基本介绍"><a href="#6-1-B树的基本介绍" class="headerlink" title="6.1 B树的基本介绍"></a>6.1 B树的基本介绍</h2><p><strong>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</strong></p><ol><li><strong>如图B树通过重新组织节点， 降低了树的高度.</strong></li><li><strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</strong></li><li><strong>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</strong></li></ol><h2 id="6-2-2-3树-基本介绍"><a href="#6-2-2-3树-基本介绍" class="headerlink" title="6.2   2-3树 基本介绍"></a>6.2   2-3树 基本介绍</h2><p><strong>2-3树是最简单的B树结构, 具有如下特点:</strong></p><ol><li><strong>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</strong></li><li><strong>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</strong></li><li><strong>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</strong></li><li><strong>2-3树是由二节点和三节点构成的树。</strong></li></ol><h2 id="6-3-B树说明"><a href="#6-3-B树说明" class="headerlink" title="6.3 B树说明"></a>6.3 B树说明</h2><ol><li><strong>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</strong></li><li><strong>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</strong></li><li><strong>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</strong></li><li><strong>搜索有可能在非叶子结点结束</strong></li><li><strong>其搜索性能等价于在关键字全集内做一次二分查找</strong></li></ol><h2 id="6-4-B-树的介绍说明"><a href="#6-4-B-树的介绍说明" class="headerlink" title="6.4 B+树的介绍说明"></a>6.4 B+树的介绍说明</h2><p><strong>B+树是B树的变体，也是一种多路搜索树。</strong></p><ol><li><strong>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</strong></li><li><strong>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</strong></li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</strong></li><li><strong>更适合文件索引系统</strong></li><li><strong>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</strong></li></ol><h2 id="6-5-B-树的介绍"><a href="#6-5-B-树的介绍" class="headerlink" title="6.5 B*树的介绍"></a>6.5 B*树的介绍</h2><p><strong>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</strong></p><ol><li><strong>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</strong></li><li><strong>从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要重写hashcode和equals方法</title>
      <link href="/2020/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode%E5%92%8Cequalsd%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode%E5%92%8Cequalsd%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 本篇博客记录了为什么要重写hashcode方法和equals方法。</p> <a id="more"></a><h1 id="一、为什么要重写hashcode和equals方法"><a href="#一、为什么要重写hashcode和equals方法" class="headerlink" title="一、为什么要重写hashcode和equals方法"></a>一、为什么要重写hashcode和equals方法</h1><h2 id="如果不被重写（原生）的hashCode和equals是什么样的？"><a href="#如果不被重写（原生）的hashCode和equals是什么样的？" class="headerlink" title="如果不被重写（原生）的hashCode和equals是什么样的？"></a><strong>如果不被重写（原生）的hashCode和equals是什么样的？</strong></h2><ol><li>没有重写hashcode和equals方法时，使用的是object父类的方法。</li><li>不被重写（原生）的hashCode值是根据<strong>内存地址</strong>换算出来的一个值。</li><li>不被重写（原生）的equals方法是严格判断一个对象是否相等的方法（object1 == object2）。</li></ol><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p><strong>当我们用HashMap存入自定义的类时，如果不重写这个自定义类的equals和hashCode方法，得到的结果会和我们预期的不一样</strong> </p><p><strong>我们创建一个HashMap对象，它的键可以存放key对象，值存放String类型对象；</strong></p><p><strong>首先我们创建2个key值相同的对象即k1，k2，它们的值都是1，我们通过put方法将k1和一串字符串放入map集合中，然后我们想用k2去HashMap里得到值，就好像我们用k1这把钥匙去关门，用k2这把钥匙去开门，这是符合逻辑的。</strong></p><p><strong>但是，如果没有重写hashcode方法和equals方法，我们得到的值就是为null，为什么呢。</strong></p><p><strong>因为当我们没有重写hashcode方法和equals方法，我们往hashmap存放k1时，首先会调用hashcode方法来计算它的hash值，而没有重写的hashcode方法是根据内存地址换算所得到的一个值</strong></p><p><strong>k1和k2为2个对象他们的地址是不同的。</strong></p><p><strong>但是我们要是重写了hashcode方法和equals方法，hashcode会根据key的值来算出他的hash值，因为k1和k2的值都是1，所以它们的哈希值是相等的，而equals方法来判断两者是否相等。</strong></p><h2 id="equals的几个特性"><a href="#equals的几个特性" class="headerlink" title="equals的几个特性"></a>equals的几个特性</h2><p><strong>1.自反性：x.equals(x) == true,自己和自己比较相等</strong></p><p><strong>2.对称性：x.equals(y) == y.equals(x),两个对象调用equals的的结果应该一样</strong></p><p><strong>3.传递性：如果x.equals(y) == true y.equals(z) == true 则 x.equals(z) == true,x和y相等，y和z相等，则x和z相等</strong></p><p><strong>4.一致性 : 如果x对象和y对象有成员变量num1和num2，其中重写的equals方法只有num1参加了运算，则修改num2不影响x.equals(y)的值</strong></p>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的负载因子为什么默认是0.75?</title>
      <link href="/2020/03/22/HashMap%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF0-75/"/>
      <url>/2020/03/22/HashMap%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4%E6%98%AF0-75/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客记录了—HashMap的负载因子为什么默认是0.75 ?</p>  <a id="more"></a><h1 id="一、负载因子的作用"><a href="#一、负载因子的作用" class="headerlink" title="一、负载因子的作用"></a>一、负载因子的作用</h1><p><strong>负载因子是和扩容机制有关的，意思是如果当前容器的容量，达到了我们设定的最大值，就要开始执行扩容操作。举个例子来解释</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如说当前的容量为<span class="number">16</span>，负载因子是<span class="number">0.75</span>，<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span>，也就是说当容量达到<span class="number">12</span>的时候就会进行扩容。</span><br></pre></td></tr></table></figure><p>  <strong>他的作用很简单，相当于是一个扩容机制的阈值。当超过了这个阈值，就会触发扩容机制</strong> </p><h1 id="二、原因解释"><a href="#二、原因解释" class="headerlink" title="二、原因解释"></a>二、原因解释</h1><p><strong>我们在考虑HashMap的时候，首先要想到的是HashMap只是一个数据结构，既然是数据结构最主要的就是节省时间和空间。负载因子的作用肯定也是节省时间和空间。为什么节省呢？</strong> </p><h2 id="1、负载因子是1-0"><a href="#1、负载因子是1-0" class="headerlink" title="1、负载因子是1.0"></a>1、负载因子是1.0</h2><p>我们的数据一开始是保存在数组里面的，当发生了Hash碰撞的时候，就是在这个数据节点上，生出一个链表，当链表长度达到一定长度的时候，就会把链表转化为红黑树。</p><p><strong>当负载因子是1.0的时候，也就意味着，只有当数组的8个值全部填充了，才会发生扩容。这就带来了很大的问题，因为Hash冲突时避免不了的。当负载因子是1.0的时候，意味着会出现大量的Hash的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。</strong></p><p><strong>因此一句话总结就是负载因子过大，虽然空间利用率上去了，但是时间效率降低了。</strong></p><h2 id="2、负载因子是0-5"><a href="#2、负载因子是0-5" class="headerlink" title="2、负载因子是0.5"></a>2、负载因子是0.5</h2><p>负载因子是0.5的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，Hash冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。</p><p>但是，兄弟们，这时候空间利用率就会大大的降低，原本存储1M的数据，现在就意味着需要2M的空间。</p><p><strong>一句话总结就是负载因子太小，虽然时间效率提升了，但是空间利用率降低了。</strong></p><h2 id="3、负载因子是0-72"><a href="#3、负载因子是0-72" class="headerlink" title="3、负载因子是0.72"></a>3、负载因子是0.72</h2><p><strong>负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</strong> </p>]]></content>
      
      
      <categories>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS文件上传</title>
      <link href="/2020/03/12/FastDFS%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/03/12/FastDFS%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><a id="more"></a><h1 id="一、FastDFS"><a href="#一、FastDFS" class="headerlink" title="一、FastDFS"></a>一、FastDFS</h1><h2 id="1-1-什么是分布式文件系统"><a href="#1-1-什么是分布式文件系统" class="headerlink" title="1.1 什么是分布式文件系统"></a>1.1 什么是分布式文件系统</h2><p>分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 </p><p>通俗来讲：</p><ul><li>传统文件系统管理的文件就存储在本机。</li><li>分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问</li></ul><h2 id="1-2-什么是FastDFS"><a href="#1-2-什么是FastDFS" class="headerlink" title="1.2 什么是FastDFS"></a>1.2 什么是FastDFS</h2><p>FastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富：</p><ul><li>文件存储</li><li>文件同步</li><li>文件访问（上传、下载）</li><li>存取负载均衡</li><li>在线扩容</li></ul><p>适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。</p><p><strong>FastDFS两个主要的角色：Tracker Server 和 Storage Server 。</strong></p><ul><li>Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 </li><li>Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息</li><li>Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 </li><li>Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。</li><li>Storage Cluster ：存储集群，有多个Group组成。</li></ul><h2 id="1-3-FastDFS使用"><a href="#1-3-FastDFS使用" class="headerlink" title="1.3  FastDFS使用"></a>1.3  FastDFS使用</h2><h3 id="1-3-1-引入依赖"><a href="#1-3-1-引入依赖" class="headerlink" title="1.3.1 引入依赖"></a>1.3.1 引入依赖</h3><p>在父工程中，我们已经管理了依赖，版本为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fastDFS.client.version</span>&gt;</span>1.26.2<span class="tag">&lt;/<span class="name">fastDFS.client.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，这里我们直接在工程的pom.xml中引入坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-引入配置类"><a href="#1-3-2-引入配置类" class="headerlink" title="1.3.2 引入配置类"></a>1.3.2 引入配置类</h3><p>纯java配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(FdfsClientConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 解决<span class="title">jmx</span>重复注册<span class="title">bean</span>的问题</span></span><br><span class="line"><span class="class">@<span class="title">EnableMBeanExport</span>(<span class="title">registration</span> </span>= RegistrationPolicy.IGNORE_EXISTING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClientImporter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-编写FastDFS属性"><a href="#1-3-3-编写FastDFS属性" class="headerlink" title="1.3.3 编写FastDFS属性"></a>1.3.3 编写FastDFS属性</h3><p>在application.yml配置文件中追加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fdfs:</span></span><br><span class="line">  <span class="attr">so-timeout:</span> <span class="number">1501</span> <span class="comment"># 超时时间</span></span><br><span class="line">  <span class="attr">connect-timeout:</span> <span class="number">601</span> <span class="comment"># 连接超时时间</span></span><br><span class="line">  <span class="attr">thumb-image:</span> <span class="comment"># 缩略图</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">60</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">tracker-list:</span> <span class="comment"># tracker地址：你的虚拟机服务器地址+端口（默认是22122）</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span><span class="string">:22122</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-测试"><a href="#1-3-4-测试" class="headerlink" title="1.3.4 测试"></a>1.3.4 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">FastDFSTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FastFileStorageClient storageClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThumbImageConfig thumbImageConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 要上传的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\joedy\\Pictures\\xbx1.jpg"</span>);</span><br><span class="line">        <span class="comment">// 上传并保存图片，参数：1-上传的文件流 2-文件的大小 3-文件的后缀 4-可以不管他</span></span><br><span class="line">        StorePath storePath = <span class="keyword">this</span>.storageClient.uploadFile(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file), file.length(), <span class="string">"jpg"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 带分组的路径</span></span><br><span class="line">        System.out.println(storePath.getFullPath());</span><br><span class="line">        <span class="comment">// 不带分组的路径</span></span><br><span class="line">        System.out.println(storePath.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUploadAndCreateThumb</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\joedy\\Pictures\\xbx1.jpg"</span>);</span><br><span class="line">        <span class="comment">// 上传并且生成缩略图</span></span><br><span class="line">        StorePath storePath = <span class="keyword">this</span>.storageClient.uploadImageAndCrtThumbImage(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file), file.length(), <span class="string">"png"</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 带分组的路径</span></span><br><span class="line">        System.out.println(storePath.getFullPath());</span><br><span class="line">        <span class="comment">// 不带分组的路径</span></span><br><span class="line">        System.out.println(storePath.getPath());</span><br><span class="line">        <span class="comment">// 获取缩略图路径</span></span><br><span class="line">        String path = thumbImageConfig.getThumbImagePath(storePath.getPath());</span><br><span class="line">        System.out.println(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-改造上传逻辑"><a href="#1-3-5-改造上传逻辑" class="headerlink" title="1.3.5 改造上传逻辑"></a>1.3.5 改造上传逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FastFileStorageClient storageClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; CONTENT_TYPES = Arrays.asList(<span class="string">"image/jpeg"</span>, <span class="string">"image/gif"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(UploadService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">// 校验文件的类型</span></span><br><span class="line">        String contentType = file.getContentType();</span><br><span class="line">        <span class="keyword">if</span> (!CONTENT_TYPES.contains(contentType))&#123;</span><br><span class="line">            <span class="comment">// 文件类型不合法，直接返回null</span></span><br><span class="line">            LOGGER.info(<span class="string">"文件类型不合法：&#123;&#125;"</span>, originalFilename);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 校验文件的内容</span></span><br><span class="line">            BufferedImage bufferedImage = ImageIO.read(file.getInputStream());</span><br><span class="line">            <span class="keyword">if</span> (bufferedImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">                LOGGER.info(<span class="string">"文件内容不合法：&#123;&#125;"</span>, originalFilename);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存到服务器</span></span><br><span class="line">            <span class="comment">// file.transferTo(new File("C:\\images\\" + originalFilename));</span></span><br><span class="line">            String ext = StringUtils.substringAfterLast(originalFilename, <span class="string">"."</span>);</span><br><span class="line">            StorePath storePath = <span class="keyword">this</span>.storageClient.uploadFile(file.getInputStream(), file.getSize(), ext, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成url地址，返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://localhost:8080/"</span> + storePath.getFullPath();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"服务器内部错误：&#123;&#125;"</span>, originalFilename);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、文件上传组件"><a href="#二、文件上传组件" class="headerlink" title="二、文件上传组件"></a>二、文件上传组件</h1><h2 id="2-1-示例："><a href="#2-1-示例：" class="headerlink" title="2.1.示例："></a>2.1.示例：</h2><h3 id="2-1-1-单图片上传："><a href="#2-1-1-单图片上传：" class="headerlink" title="2.1.1.单图片上传："></a>2.1.1.单图片上传：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-upload</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-model</span>=<span class="string">"brand.image"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">url</span>=<span class="string">"/item/upload"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">:multiple</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">:pic-width</span>=<span class="string">"150"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">:pic-height</span>=<span class="string">"150"</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-1-2-多图片上传"><a href="#2-1-2-多图片上传" class="headerlink" title="2.1.2.多图片上传"></a>2.1.2.多图片上传</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-upload</span></span></span><br><span class="line"><span class="tag">          <span class="attr">v-model</span>=<span class="string">"brand.image"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">url</span>=<span class="string">"/item/upload"</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-属性列表："><a href="#2-2-属性列表：" class="headerlink" title="2.2.属性列表："></a>2.2.属性列表：</h2><table><thead><tr><th>属性名</th><th>说明</th><th>数据类型</th><th>默认值</th></tr></thead><tbody><tr><td>url</td><td>上传文件的目标路径</td><td>String</td><td>无</td></tr><tr><td>value</td><td>上传成功的返回结果</td><td>单图片上传是String。多图片上传是String数组</td><td>无</td></tr><tr><td>multiple</td><td>是否运行多图片上传</td><td>Boolean</td><td>true</td></tr><tr><td>picWidth</td><td>单图片上传后的预览宽度</td><td>Number</td><td>150</td></tr><tr><td>picHeight</td><td>单图片上传后的预览高度</td><td>Number</td><td>150</td></tr></tbody></table><h2 id="2-3-说明"><a href="#2-3-说明" class="headerlink" title="2.3.说明"></a>2.3.说明</h2><p>可以通过v-model双向绑定，来获取图片上传的结果：</p><ul><li>单图片上传时，value值是一个图片地址</li><li>多图片上传时，value值是一个图片地址数组</li><li>文件上传的参数名是：file</li><li>文件上传的返回值，就是图片的url路径</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找算法</title>
      <link href="/2020/03/04/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/04/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客介绍了4种查找算法，分别是顺序查找、二分查找、插值查找、斐波那契查找。</p> <a id="more"></a><h1 id="第一章-查找算法介绍"><a href="#第一章-查找算法介绍" class="headerlink" title="第一章 查找算法介绍"></a>第一章 查找算法介绍</h1><p><strong>在java中，我们常用的查找有四种:</strong></p><p>1)顺序(线性)查找</p><p>2) 二分查找/折半查找</p><p>3)插值查找</p><p>4) 斐波那契查找</p><h1 id="第二章-线性查找算法"><a href="#第二章-线性查找算法" class="headerlink" title="第二章 线性查找算法"></a>第二章 线性查找算法</h1><h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个数列： &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125; ，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值。</span><br></pre></td></tr></table></figure><p> 思路：如果查找到全部符合条件的值。[思路分析.]  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] == value) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章-二分查找算法"><a href="#第三章-二分查找算法" class="headerlink" title="第三章 二分查找算法"></a>第三章 二分查找算法</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请对一个有序数组进行二分查找 &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125; ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示<span class="string">"没有这个数"</span>。</span><br></pre></td></tr></table></figure><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二分查找的思路分析</span><br><span class="line"><span class="number">1</span>. 首先确定该数组的中间的下标</span><br><span class="line">mid = (left + right) / <span class="number">2</span></span><br><span class="line"><span class="number">2</span>. 然后让需要查找的数 findVal 和 arr[mid] 比较</span><br><span class="line"><span class="number">2</span>. <span class="number">1</span> findVal &gt; arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找</span><br><span class="line"><span class="number">2.2</span> findVal &lt; arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找</span><br><span class="line"><span class="number">2.3</span>  findVal == arr[mid] 说明找到，就返回</span><br><span class="line"></span><br><span class="line"><span class="comment">//什么时候我们需要结束递归.</span></span><br><span class="line"><span class="number">1</span>) 找到就结束递归 </span><br><span class="line"><span class="number">2</span>) 递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left &gt; right 就需要退出</span><br></pre></td></tr></table></figure><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>只有一个需要查找的值时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">erfenSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> findVal)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">       <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (findVal&gt;midVal)&#123; <span class="comment">//向右递归</span></span><br><span class="line">           <span class="keyword">return</span> erfenSearch(arr,mid+<span class="number">1</span>,right,findVal);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt; midVal)&#123; <span class="comment">//向左递归</span></span><br><span class="line">           <span class="keyword">return</span> erfenSearch(arr,left,mid-<span class="number">1</span>,findVal);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>有多个相同的数值时</strong>（优化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment">   * 有多个相同的数值时，如何将所有的数值都查找到</span></span><br><span class="line"><span class="comment">   * 思路分析</span></span><br><span class="line"><span class="comment">   * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment">   * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">   * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">   * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">erfenSearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left , <span class="keyword">int</span> right , <span class="keyword">int</span> findVal)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">      <span class="keyword">if</span> (left&gt;right)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (findVal&gt;midVal)&#123; <span class="comment">//向右递归</span></span><br><span class="line">          <span class="keyword">return</span> erfenSearch2(arr,mid+<span class="number">1</span>,right,findVal);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span> (findVal&lt; midVal)&#123; <span class="comment">//向左递归</span></span><br><span class="line">          <span class="keyword">return</span> erfenSearch2(arr,left,mid-<span class="number">1</span>,findVal);</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">int</span> temp = mid-<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span> (temp&lt;<span class="number">0</span> || arr[temp] != findVal)&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              list.add(temp);</span><br><span class="line">              temp--;</span><br><span class="line">          &#125;</span><br><span class="line">          list.add(mid);</span><br><span class="line">          temp = mid+<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span> (temp&gt;arr.length-<span class="number">1</span> || arr[temp] != findVal)&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              list.add(temp);</span><br><span class="line">              temp++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-插值查找算法"><a href="#第四章-插值查找算法" class="headerlink" title="第四章 插值查找算法"></a>第四章 插值查找算法</h1><h2 id="插值插值"><a href="#插值插值" class="headerlink" title="插值插值"></a>插值插值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。</span><br><span class="line"><span class="number">2</span>.将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是需要查找的值</span><br><span class="line"><span class="number">3</span>.<span class="keyword">int</span> mid = left + (right – left) * (findVal – arr[left]) / (arr[right] -arr[left])</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">数组  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ......., <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">假如我们需要查找的值  <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">使用二分查找的话，我们需要多次递归，才能找到 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">使用插值查找算法</span><br><span class="line"><span class="keyword">int</span> mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span> + (<span class="number">99</span> - <span class="number">0</span>) * (<span class="number">1</span> - <span class="number">1</span>)/ (<span class="number">100</span> - <span class="number">1</span>) = <span class="number">0</span> + <span class="number">99</span> * <span class="number">0</span> / <span class="number">99</span> = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">比如我们查找的值 <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span> + (<span class="number">99</span> - <span class="number">0</span>) * (<span class="number">100</span> - <span class="number">1</span>) / (<span class="number">100</span> - <span class="number">1</span>) = <span class="number">0</span> + <span class="number">99</span> * <span class="number">99</span> / <span class="number">99</span> = <span class="number">0</span> + <span class="number">99</span> = <span class="number">99</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.</span><br><span class="line"><span class="number">2</span>.关键字分布不均匀的情况下，该方法不一定比二分查找要好</span><br></pre></td></tr></table></figure><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写插值查找算法</span></span><br><span class="line"><span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出mid, 自适应</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-斐波那契查找算法"><a href="#第五章-斐波那契查找算法" class="headerlink" title="第五章 斐波那契查找算法"></a>第五章 斐波那契查找算法</h1><h2 id="斐波那契（黄金分割法）查找算法介绍"><a href="#斐波那契（黄金分割法）查找算法介绍" class="headerlink" title="斐波那契（黄金分割法）查找算法介绍"></a>斐波那契（黄金分割法）查找算法介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是<span class="number">0.618</span>。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</span><br><span class="line"><span class="number">2</span>.斐波那契数列 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span> &#125; 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值<span class="number">0.618</span></span><br></pre></td></tr></table></figure><h2 id="斐波那契-黄金分割法-原理"><a href="#斐波那契-黄金分割法-原理" class="headerlink" title="斐波那契(黄金分割法)原理"></a>斐波那契(黄金分割法)原理</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k<span class="number">-1</span>)<span class="number">-1</span>（F代表斐波那契数列）。</span><br><span class="line"></span><br><span class="line">对F(k<span class="number">-1</span>)<span class="number">-1</span>的理解：</span><br><span class="line">由斐波那契数列 F[k]=F[k<span class="number">-1</span>]+F[k<span class="number">-2</span>] 的性质，可以得到 （F[k]<span class="number">-1</span>）=（F[k<span class="number">-1</span>]<span class="number">-1</span>）+（F[k<span class="number">-2</span>]<span class="number">-1</span>）+<span class="number">1</span> 。该式说明：只要顺序表的长度为F[k]<span class="number">-1</span>，则可以将该表分成长度为F[k<span class="number">-1</span>]<span class="number">-1</span>和F[k<span class="number">-2</span>]<span class="number">-1</span>的两段，。从而中间位置为mid=low+F(k<span class="number">-1</span>)<span class="number">-1</span>           </span><br><span class="line"></span><br><span class="line">类似的，每一子段也可以用相同的方式分割</span><br><span class="line">但顺序表长度n不一定刚好等于F[k]<span class="number">-1</span>，所以需要将原来的顺序表长度n增加至F[k]<span class="number">-1</span>。这里的k值只要能使得F[k]<span class="number">-1</span>恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+<span class="number">1</span>到F[k]<span class="number">-1</span>位置），都赋为n位置的值即可。</span><br></pre></td></tr></table></figure><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line"><span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line"><span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line"><span class="comment">//不足的部分会使用0填充</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line"><span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line"><span class="comment">//举例:</span></span><br><span class="line"><span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为甚是 k--</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line"><span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line"><span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">k--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是k -=2</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line"><span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line"><span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">k -= <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 查找算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法</title>
      <link href="/2020/02/28/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/28/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客介绍了八大排序算法思想及代码实现，分别是冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、桶排序、堆排序。</p>  <a id="more"></a><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><h2 id="基本介绍及思想"><a href="#基本介绍及思想" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p><strong>冒泡排序（Bubble Sorting）的基本思想是</strong>：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><p>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序</strong>，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。</p><h2 id="冒泡排序算法的过程"><a href="#冒泡排序算法的过程" class="headerlink" title="冒泡排序算法的过程"></a>冒泡排序算法的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">原始数组：<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">第一趟排序</span><br><span class="line">(<span class="number">1</span>)  <span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">20</span>   <span class="comment">// 如果相邻的元素逆序就交换</span></span><br><span class="line">(<span class="number">2</span>)  <span class="number">3</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">(<span class="number">3</span>)  <span class="number">3</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">(<span class="number">4</span>)  <span class="number">3</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">第二趟排序</span><br><span class="line">(<span class="number">1</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span> <span class="comment">//交换</span></span><br><span class="line">(<span class="number">2</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">(<span class="number">3</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">第三趟排序</span><br><span class="line">(<span class="number">1</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">(<span class="number">2</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">第四趟排序</span><br><span class="line">(<span class="number">1</span>) -<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结冒泡排序规则</span><br><span class="line">(<span class="number">1</span>) 一共进行 数组的大小-<span class="number">1</span> 次 大的循环</span><br><span class="line">(<span class="number">2</span>)每一趟排序的次数在逐渐的减少</span><br><span class="line">(<span class="number">3</span>) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</span><br></pre></td></tr></table></figure><h2 id="冒泡排序算法的代码实现"><a href="#冒泡排序算法的代码实现" class="headerlink" title="冒泡排序算法的代码实现"></a>冒泡排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">maopaoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maopaoSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//标识变量，表示是否交换过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//表示在一段排序中，没有进行过交换</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;<span class="comment">//重置flag，进行下次判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><h2 id="基本介绍及思想-1"><a href="#基本介绍及思想-1" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p><strong>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是</strong>：第一次从arr[0]<del>arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]</del>arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]<del>arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]</del>arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列  </p><h2 id="选择排序算法的过程"><a href="#选择排序算法的过程" class="headerlink" title="选择排序算法的过程"></a>选择排序算法的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原始的数组 ： <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span></span><br><span class="line">第一轮排序 :   <span class="number">1</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">101</span></span><br><span class="line">第二轮排序 :   <span class="number">1</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">101</span></span><br><span class="line">第三轮排序 :   <span class="number">1</span>, <span class="number">34</span>, <span class="number">101</span>, <span class="number">119</span></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>. 选择排序一共有 数组大小 - <span class="number">1</span> 轮排序</span><br><span class="line"><span class="number">2</span>. 每<span class="number">1</span>轮排序，又是一个循环, 循环的规则(代码)</span><br><span class="line"><span class="number">2.1</span>先假定当前这个数是最小数</span><br><span class="line"><span class="number">2.2</span> 然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标</span><br><span class="line"><span class="number">2.3</span> 当遍历到数组的最后时，就得到本轮最小数和下标</span><br><span class="line"><span class="number">2.4</span> 交换 [代码中再继续说 ]</span><br></pre></td></tr></table></figure><h2 id="选择排序算法的代码实现"><a href="#选择排序算法的代码实现" class="headerlink" title="选择排序算法的代码实现"></a>选择排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xuanzheSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xuanzheSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[min] &gt; arr[j])&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将找到的最小值和第一个数进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(min != i) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[min];</span><br><span class="line">                arr[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"次排序后的数据为"</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h1><h2 id="基本介绍及思想-2"><a href="#基本介绍及思想-2" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p><strong>插入排序的基本思想：</strong> <strong>把n个待排序的元素看成一个有序表和一个无序表，</strong>开始时<strong>有序表只包含一个元素</strong>，无序表中包含<strong>n-1个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h2 id="插入排序算法的代码实现"><a href="#插入排序算法的代码实现" class="headerlink" title="插入排序算法的代码实现"></a>插入排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">charuSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">charuSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="comment">//定义需要插入的值</span></span><br><span class="line">            <span class="keyword">int</span> value = arr[i];</span><br><span class="line">            <span class="comment">//插入这个值的前面这个数的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给value找到需要插入的位置</span></span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//1.index &gt;=0 保证 给value值找插入位置的时候，不越界</span></span><br><span class="line">            <span class="comment">//2.value &lt; arr[index]  待插入的数，还没有找到插入位置</span></span><br><span class="line">            <span class="comment">//3.就需要arr[index] 后移</span></span><br><span class="line">            <span class="keyword">while</span> (index &gt;=<span class="number">0</span> &amp;&amp; value &lt; arr[index])&#123;</span><br><span class="line">                arr[index+<span class="number">1</span>] = arr[index];</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当退出while循环时，说明插入的位置找到了，在index+1的位置</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = value;</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+i+<span class="string">"次排序后的数据"</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><h2 id="基本介绍及思想-3"><a href="#基本介绍及思想-3" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至1时</strong>，整个文件恰被分成一组，算法便终止。</p><h2 id="希尔排序算法的代码实现"><a href="#希尔排序算法的代码实现" class="headerlink" title="希尔排序算法的代码实现"></a>希尔排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序(插入使用交换法)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xierSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        System.out.println();</span><br><span class="line">        xierSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//希尔排序(插入使用交换法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xierSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>;gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap ; i&lt;arr.length ; i++)&#123;</span><br><span class="line">                <span class="comment">//遍历各组中所有的元素(一共有gap组)，步长为gap步</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i-gap;j&gt;=<span class="number">0</span>;j -= gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j+gap])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j+gap];</span><br><span class="line">                        arr[j+gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><h2 id="基本介绍及思想-4"><a href="#基本介绍及思想-4" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p><strong>快速排序是对冒泡排序的一种改进。基本思想是</strong>：通过一趟排序将要排序的数据分割成<strong>独立的两部分</strong>，其中一部分的所有数据都比另外一部分的数据都要小，然后再按此方法对两部分数据分别进行快速排序，<strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列。</p><h2 id="快速排序算法的代码实现"><a href="#快速排序算法的代码实现" class="headerlink" title="快速排序算法的代码实现"></a>快速排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kuaishuSort</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kuaishuSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l =left;<span class="comment">//左下标</span></span><br><span class="line">        <span class="keyword">int</span> r = right;<span class="comment">//右下标</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left+right) / <span class="number">2</span>];<span class="comment">//中间值</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot值小的放在左边，比pivot值大的放在右边</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找，找到大于等于pivot的值，才退出</span></span><br><span class="line">             <span class="keyword">while</span> (arr[l] &lt; pivot)&#123;</span><br><span class="line">                 l++;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找，找到小于等于pivot的值，才退出</span></span><br><span class="line">             <span class="keyword">while</span> (arr[r]&gt; pivot)&#123;</span><br><span class="line">                 r--;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//如果l&gt;=r说明 pivot的左右两边的值，已经按照左边全部是小于等于pivot的值，右边是大于等于pivot的值</span></span><br><span class="line">             <span class="keyword">if</span> (l&gt;=r)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//交换</span></span><br><span class="line">             <span class="keyword">int</span> temp = arr[l];</span><br><span class="line">             arr[l] = arr[r];</span><br><span class="line">             arr[r] = temp;</span><br><span class="line">             <span class="comment">//如果交换完后发现arr[l] = pivot r--,</span></span><br><span class="line">             <span class="keyword">if</span> (arr[l] == pivot)&#123;</span><br><span class="line">                 r--;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="comment">//如果交换完后发现arr[r] = pivot l--,</span></span><br><span class="line">             <span class="keyword">if</span> (arr[r] == pivot)&#123;</span><br><span class="line">                 l++;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果l == r,必须l++，r--,否则会出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;r)&#123;</span><br><span class="line">            kuaishuSort(arr,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right&gt;l)&#123;</span><br><span class="line">            kuaishuSort(arr,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h1><h2 id="基本介绍及思想-5"><a href="#基本介绍及思想-5" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治策略</strong>（分治法将问题分成一些<strong>小的问题然后递归求解</strong>，而治的阶段则将分的阶段得到的各答案修补在一起，即分而治之）。</p><h2 id="归并排序算法的代码实现"><a href="#归并排序算法的代码实现" class="headerlink" title="归并排序算法的代码实现"></a>归并排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">guibinSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid  中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(一)</span></span><br><span class="line">        <span class="comment">//先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">//然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(二)</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid)&#123;   <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=right)&#123;   <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(三)</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">        <span class="comment">//第一次合并 tempLeft = 0 , right = 1</span></span><br><span class="line">        <span class="comment">// tempLeft = 2  right = 3</span></span><br><span class="line">        <span class="comment">// tL=0 ri=3</span></span><br><span class="line">        <span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right)&#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            tempLeft++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、基数排序"><a href="#七、基数排序" class="headerlink" title="七、基数排序"></a>七、基数排序</h1><h2 id="基本介绍及思想-6"><a href="#基本介绍及思想-6" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h2 id="基数排序算法的过程"><a href="#基数排序算法的过程" class="headerlink" title="基数排序算法的过程"></a>基数排序算法的过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数组的初始状态 </span><br><span class="line">arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125; </span><br><span class="line"></span><br><span class="line">第<span class="number">1</span>轮排序:</span><br><span class="line">(<span class="number">1</span>) 将每个元素的个位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)</span><br><span class="line">(<span class="number">2</span>) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">数组的第<span class="number">1</span>轮排序 </span><br><span class="line">arr = &#123;<span class="number">542</span>, <span class="number">53</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">214</span>, <span class="number">748</span>&#125;  </span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>轮排序:</span><br><span class="line">(<span class="number">1</span>) 将每个元素的十位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)</span><br><span class="line">(<span class="number">2</span>) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">数组的第<span class="number">2</span>轮排序 </span><br><span class="line">arr = &#123;<span class="number">3</span>, <span class="number">14</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">53</span>&#125;  </span><br><span class="line"></span><br><span class="line">第<span class="number">3</span>轮排序:</span><br><span class="line">(<span class="number">1</span>) 将每个元素百位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)</span><br><span class="line">(<span class="number">2</span>) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">数组的第<span class="number">3</span>轮排序 </span><br><span class="line">arr = &#123;<span class="number">3</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">214</span>, <span class="number">542</span>, <span class="number">748</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序算法的代码实现"><a href="#基数排序算法的代码实现" class="headerlink" title="基数排序算法的代码实现"></a>基数排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序（桶排序）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tongSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tongSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">        <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">        <span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//可以这里理解</span></span><br><span class="line">        <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//这里我们使用循环将代码处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">                <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入到对应的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketCounts.length; k++) &#123;</span><br><span class="line">                <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">                <span class="keyword">if</span> (bucketCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketCounts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">                bucketCounts[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、堆排序"><a href="#八、堆排序" class="headerlink" title="八、堆排序"></a>八、堆排序</h1><h2 id="基本介绍及思想-7"><a href="#基本介绍及思想-7" class="headerlink" title="基本介绍及思想"></a>基本介绍及思想</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</span><br><span class="line">堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</span><br><span class="line">每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</span><br></pre></td></tr></table></figure><p><strong>思想</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">堆排序的基本思想是：</span><br><span class="line"><span class="number">1</span>.将待排序序列构造成一个大顶堆</span><br><span class="line"><span class="number">2</span>.此时，整个序列的最大值就是堆顶的根节点。</span><br><span class="line"><span class="number">3</span>.将其与末尾元素进行交换，此时末尾就为最大值。</span><br><span class="line"><span class="number">4</span>.然后将剩余n-<span class="number">1</span>个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</span><br></pre></td></tr></table></figure><h2 id="桶排序算法的代码实现"><a href="#桶排序算法的代码实现" class="headerlink" title="桶排序算法的代码实现"></a>桶排序算法的代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duiSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">          duiSort(arr,i,arr.length);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">　　3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">          <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">          arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">          arr[<span class="number">0</span>] = temp;</span><br><span class="line">          duiSort(arr,<span class="number">0</span>,j);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ----------------------------------------------------------</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> lenght 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">duiSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> lenght)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">      <span class="comment">//开始调整</span></span><br><span class="line">      <span class="comment">//说明</span></span><br><span class="line">      <span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(k+<span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123; <span class="comment">//说明左子结点的值小于右子结点的值</span></span><br><span class="line">              k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(arr[k] &gt; temp) &#123; <span class="comment">//如果子结点大于父结点</span></span><br><span class="line">              arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">              i = k; <span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;<span class="comment">//!</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">      arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot异步任务与定时任务</title>
      <link href="/2020/02/18/SpringBoot%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2020/02/18/SpringBoot%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客介绍SpringBoot异步任务和定时任务调度的实战</p><a id="more"></a><h1 id="一、-Spring-Boot-异步任务实战"><a href="#一、-Spring-Boot-异步任务实战" class="headerlink" title="一、  Spring Boot 异步任务实战"></a>一、  Spring Boot 异步任务实战</h1><ul><li>在项目开发中，绝大多数情况下都是通过同步方式处理业务逻辑的，但是比如批量处理数据，批量发送邮件，批量发送短信等操作 容易造成阻塞的情况，之前大部分都是使用多线程来完成此类任务。 而在Spring 3+之后，就已经内置了 <strong>@Async 注解</strong>来完美解决这个问题，从而提高效率。</li><li>使用的注解 <ul><li>@EnableAysnc 启动类上开启基于注解的异步任务 </li><li>@Aysnc 标识的方法会异步执行 </li></ul></li><li>实战步骤</li></ul><p><strong>Service层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxt.springboot.service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"批量下载中..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Controller层</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lxt.springboot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lxt.springboot.service.AsyncService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsynController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        asyncService.add();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootTaskApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootTaskApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、Spring-Boot-定时任务调度实战"><a href="#二、Spring-Boot-定时任务调度实战" class="headerlink" title="二、Spring Boot 定时任务调度实战"></a>二、Spring Boot 定时任务调度实战</h1><ul><li>在项目开发中，经常需要执行一些定时任务，比如 每月1号凌晨需要汇总上个月的数据分析报表; 每天凌晨分 析前一天的日志信息等定时操作。Spring 为我们提供了异步执行定时任务调度的方式。  </li><li><strong>使用的注解 ：</strong><ul><li>@EnableScheduling 启动类上开启基于注解的定时任务 </li><li>@Scheduled 标识的方法会进行定时处理 <ul><li>需要通过 cron 属性来指定 cron 表达式： 秒 分 时 日 月 星期几 </li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"*/3 * * * * MON-FRI"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数据统计第"</span>+ count++ + <span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cron表达式  </li></ul><table><thead><tr><th>位置</th><th>取值范围</th><th>可指定的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日期</td><td>1-31</td><td>, - * ? / L W C</td></tr><tr><td>月份</td><td>1-12</td><td>, - * /</td></tr><tr><td>星期</td><td>0-7或SUN-SAT 0和7都是周日，1-6是周一到周六</td><td>, - * ? / L C #</td></tr></tbody></table><table><thead><tr><th>特 殊 字 符</th><th>代表含义</th></tr></thead><tbody><tr><td>,</td><td>枚举，一个位置上指定多个值，以逗号 ， 分隔</td></tr><tr><td>-</td><td>区间</td></tr><tr><td>*</td><td>任意</td></tr><tr><td>/</td><td>步长，每隔多久执行一次</td></tr><tr><td>？</td><td>日/星期冲突匹配 ,指定哪个值,另外个就是?，比如： * * * ? * 1 每周1执行，则日用 ？ 不能用 * ，不 是每一天都是周一； * * * * 2 * ? 每月2号,则星期不能用*</td></tr><tr><td>L</td><td>最后</td></tr><tr><td>W</td><td>工作日</td></tr><tr><td>C</td><td>和calendar联系后计算过的值</td></tr><tr><td>#</td><td>这个月的第几个星期几，4#2，第2个星期四</td></tr></tbody></table><ul><li><p><strong>在线生成cron表达式 <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></strong> </p></li><li><pre><code class="java"><span class="number">1</span>-<span class="number">5</span> * * * * <span class="number">1</span>到<span class="number">5</span>秒，每秒都触发任务*/<span class="number">5</span> * * * * 每隔<span class="number">5</span>秒执行一次<span class="number">0</span> */<span class="number">1</span> * * * 每隔<span class="number">1</span>分钟执行一次<span class="number">0</span> <span class="number">0</span> <span class="number">5</span>-<span class="number">15</span> * * 每天<span class="number">5</span>-<span class="number">15</span>点整点触发<span class="number">0</span> <span class="number">0</span>-<span class="number">5</span> <span class="number">14</span> * * 在每天下午<span class="number">2</span>点到下午<span class="number">2</span>:<span class="number">05</span>期间的每<span class="number">1</span>分钟触发<span class="number">0</span> <span class="number">0</span>/<span class="number">5</span> <span class="number">14</span> * * 在每天下午<span class="number">2</span>点到下午<span class="number">2</span>:<span class="number">55</span>期间的每<span class="number">5</span>分钟触发<span class="number">0</span> <span class="number">0</span>/<span class="number">5</span> <span class="number">14</span>,<span class="number">18</span> * * 在每天下午<span class="number">2</span>点到<span class="number">2</span>:<span class="number">55</span>期间和下午<span class="number">6</span>点到<span class="number">6</span>:<span class="number">55</span>期间的每<span class="number">5</span>分钟触发<span class="number">0</span> <span class="number">0</span>/<span class="number">30</span> <span class="number">9</span>-<span class="number">17</span> * * 朝九晚五工作时间内每半小时<span class="number">0</span> <span class="number">0</span> <span class="number">12</span> ? * WED 表示每个星期三中午<span class="number">12</span>点<span class="number">0</span> <span class="number">10</span>,<span class="number">44</span> <span class="number">14</span> ? <span class="number">3</span> WED 每年三月的星期三的下午<span class="number">2</span>:<span class="number">10</span>和<span class="number">2</span>:<span class="number">44</span>触发<span class="number">0</span> <span class="number">0</span> <span class="number">23</span> L * ? 每月最后一天<span class="number">23</span>点执行一次<span class="number">0</span> <span class="number">15</span> <span class="number">10</span> LW * ? 每个月最后一个工作日的<span class="number">10</span>点<span class="number">15</span>分<span class="number">0</span>秒触发任务0 15 10 ? * 5#3 每个月第三周的星期五的10点15分0秒触发任务</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实战---SSM后台权限管理系统</title>
      <link href="/2020/02/13/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-SSM%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/02/13/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-SSM%E5%90%8E%E5%8F%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本实战项目为SSM后台权限管理系统，采用的框架为SSM框架即(Spring，SpringMvc，MyBatsi)，Spring Security，采用maven工程搭建，主要实现的功能有:商品查询，商品添加，商品删除，订单查询，订单删除，订单分页查询，订单详情查询，用户管理（包括用户查询，添加，查看详情），角色查询（包括角色查询，添加），资源权限管理（包括权限的查询，添加操作），权限关联（用户角色关联，角色权限关联）。本篇博客记录项目中遇到的难点</p><a id="more"></a><h1 id="1-项目地址"><a href="#1-项目地址" class="headerlink" title="1.项目地址"></a>1.项目地址</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/lxtbiu/SSM-Jurisdiction.git</span></span><br></pre></td></tr></table></figure><h1 id="2-如何实现SSM整合"><a href="#2-如何实现SSM整合" class="headerlink" title="2. 如何实现SSM整合"></a>2. 如何实现SSM整合</h1><h2 id="2-1-Spring环境搭建"><a href="#2-1-Spring环境搭建" class="headerlink" title="2.1 Spring环境搭建"></a>2.1 Spring环境搭建</h2><h3 id="2-1-1-编写Spring配置文件applicationContext-xml"><a href="#2-1-1-编写Spring配置文件applicationContext-xml" class="headerlink" title="2.1.1.编写Spring配置文件applicationContext.xml"></a>2.1.1.编写Spring配置文件applicationContext.xml</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span><br><span class="line">&lt;!-- 开启注解扫描，管理service和dao --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.lxt.ssm.service"</span>&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.lxt.ssm.dao"</span>&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-Spring-MVC-环境搭建"><a href="#2-2-Spring-MVC-环境搭建" class="headerlink" title="2.2 Spring MVC 环境搭建"></a>2.2 Spring MVC 环境搭建</h2><h3 id="2-2-1-web-xml配置Spring-MVC核心控制器"><a href="#2-2-1-web-xml配置Spring-MVC核心控制器" class="headerlink" title="2.2.1.web.xml配置Spring MVC核心控制器"></a>2.2.1.web.xml配置Spring MVC核心控制器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置 spring mvc 的核心控制器 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- 配置初始化参数，用于读取 <span class="title">springmvc</span> 的配置文件 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line">&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;!-- 配置 servlet 的对象的创建时间点：应用加载时创建。取值只能是非 <span class="number">0</span> 正整数，表示启动顺 序 --&gt;</span><br><span class="line">&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;springmvcDispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;!-- 配置 springMVC 编码过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- 设置过滤器中的属性值 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">UTF</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- 启动过滤器 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">forceEncoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">true</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;!-- 过滤所有请求 --&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-Spring-MVC配置文件springmvc-xml"><a href="#2-2-2-Spring-MVC配置文件springmvc-xml" class="headerlink" title="2.2.2.Spring MVC配置文件springmvc.xml"></a>2.2.2.Spring MVC配置文件springmvc.xml</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描controller的注解，别的不扫描 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.lxt.ssm.controller"</span>&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line">&lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"viewResolver"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">&lt;!-- JSP文件所在的目录 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/pages/"</span> /&gt;</span><br><span class="line">&lt;!-- 文件的后缀名 --&gt;</span><br><span class="line">&lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 设置静态资源不过滤 --&gt;</span><br><span class="line">&lt;mvc:resources location=<span class="string">"/css/"</span> mapping=<span class="string">"/css/**"</span> /&gt;</span><br><span class="line">&lt;mvc:resources location=<span class="string">"/img/"</span> mapping=<span class="string">"/img/**"</span> /&gt;</span><br><span class="line">&lt;mvc:resources location=<span class="string">"/js/"</span> mapping=<span class="string">"/js/**"</span> /&gt;</span><br><span class="line">&lt;mvc:resources location=<span class="string">"/plugins/"</span> mapping=<span class="string">"/plugins/**"</span> /&gt;</span><br><span class="line">&lt;!-- 开启对SpringMVC注解的支持 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">支持AOP的注解支持，AOP底层使用代理技术</span><br><span class="line">JDK动态代理，要求必须有接口</span><br><span class="line">cglib代理，生成子类对象，proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">"true"</span> 默认使用cglib的方式</span><br><span class="line">--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">"true"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="2-3-Spring与Spring-MVC整合"><a href="#2-3-Spring与Spring-MVC整合" class="headerlink" title="2.3 Spring与Spring MVC整合"></a>2.3 Spring与Spring MVC整合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置加载类路径的配置文件 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath*:applicationContext.xml,classpath*:spring-security.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!-- 配置监听器 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-Spring与MyBatis整合"><a href="#2-4-Spring与MyBatis整合" class="headerlink" title="2.4 Spring与MyBatis整合  *"></a>2.4 Spring与MyBatis整合  *</h2><p> 2.4.1.整合思路  </p><p>把 mybatis 配置文件（mybatis.xml）中内容配置到 spring 配置文件中 同时，把 mybatis 配置文件的内容清掉 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p> 2.4.2.Spring接管mybatis的Session工厂 </p><p> db.properties </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=<span class="string">"classpath:db.properties"</span>/&gt;</span><br><span class="line">&lt;!-- 配置连接池 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">"user"</span> value=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><br><span class="line">&lt;property name=<span class="string">"password"</span> value=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 把交给IOC管理 SqlSessionFactory --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"sqlSessionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 2.4.3.自动扫描所有Mapper接口和文件 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扫描dao接口 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"mapperScanner"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"basePackage"</span> value=<span class="string">"com.lxt.ssm.dao"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 2.4.4.配置Spring事务 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring的声明式事务管理 --&gt;</span><br><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"transactionManager"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span>/&gt;</span><br></pre></td></tr></table></figure><h1 id="3-如何进行分页查询"><a href="#3-如何进行分页查询" class="headerlink" title="3.如何进行分页查询"></a>3.如何进行分页查询</h1><h2 id="3-1-PageHelper介绍"><a href="#3-1-PageHelper介绍" class="headerlink" title="3.1 PageHelper介绍"></a>3.1 PageHelper介绍</h2><p>PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，例如mysql、 oracle、mariaDB、DB2、SQLite、Hsqldb等。 </p><p>本项目在 github 的项目地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper</a>  </p><h2 id="3-2-PageHelper使用"><a href="#3-2-PageHelper使用" class="headerlink" title="3.2 PageHelper使用"></a>3.2 PageHelper使用</h2><p>引入分页插件有下面2种方式，推荐使用 Maven 方式。 </p><p>使用<strong>Maven</strong></p><p> 在 pom.xml 中添加如下依赖： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;最新版本&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p> <strong>.配置</strong> </p><p> 特别注意，新版拦截器是 com.github.pagehelper.PageInterceptor 。 com.github.pagehelper.PageHelper 现 在是一个特殊的 dialect 实现类，是分页插件的默认实现类，提供了和以前相同的用法。 </p><p> <strong>在 MyBatis 配置 xml 中配置拦截器插件</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:</span><br><span class="line">    properties?, settings?,</span><br><span class="line">    typeAliases?, typeHandlers?,</span><br><span class="line">    objectFactory?,objectWrapperFactory?,</span><br><span class="line">    plugins?,</span><br><span class="line">    environments?, databaseIdProvider?, mappers?</span><br><span class="line">--&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span><br><span class="line">        &lt;plugin interceptor=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span><br><span class="line">        &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"param1"</span> value=<span class="string">"value1"</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p> <strong>在 Spring 配置文件中配置拦截器插件</strong> </p><p> 使用 spring 的属性配置方式，可以使用 plugins 属性像下面这样配置： </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"sqlSessionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span><br><span class="line">    &lt;!-- 注意其他配置 --&gt;</span><br><span class="line">    &lt;property name=<span class="string">"plugins"</span>&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"properties"</span>&gt;</span><br><span class="line">                &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;</span><br><span class="line">                    &lt;value&gt;</span><br><span class="line">                    params=value1</span><br><span class="line">                    &lt;/value&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="3-3-分页插件参数介绍"><a href="#3-3-分页插件参数介绍" class="headerlink" title="3.3  分页插件参数介绍"></a>3.3  分页插件参数介绍</h2><ul><li><strong>helperDialect</strong> ：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置 helperDialect 属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值： oracle , mysql , mariadb , sqlite , hsqldb , postgresql , db2 , sqlserver , informix , h2 , sqlserver2012 , derby 。</li></ul><p><strong>特别注意：</strong>使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012 ，否则会使用 SqlServer2005 的 方式进行分页。 你也可以实现 AbstractHelperDialect ，然后配置该属性为实现类的全限定名称即可使用自定义的实现方 法。</p><ul><li><strong>offsetAsPageNum</strong> ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。</li><li><strong>rowBoundsWithCount</strong> ：默认值为 false ，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置 为 true 时，使用 RowBounds 分页会进行 count 查询。</li><li><strong>pageSizeZero</strong> ：默认值为 false ，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。</li><li><strong>reasonable</strong> ：分页合理化参数，默认值为 false 。当该参数设置为 true 时， pageNum&lt;=0 时会查询第一 页， pageNum&gt;pages （超过总数时），会查询最后一页。默认 false 时，直接根据参数进行查询。</li><li><strong>params</strong> ：为了支持 startPage(Object params) 方法，增加了该参数来配置参数映射，用于从对象中根据属 性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable ，不配置映射的用默认值， 默认 值为 pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero 。 </li><li><strong>supportMethodsArguments</strong> ：支持通过 Mapper 接口参数来传递分页参数，默认值 false ，分页插件会从查 询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法 可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest 。</li><li><strong>autoRuntimeDialect</strong> ：默认值为 false 。设置为 true 时，允许在运行时根据多数据源自动识别对应方言 的分页 （不支持自动选择 sqlserver2012 ，只能使用 sqlserver ），用法和注意事项参考下面的场景五。</li><li><strong>closeConn</strong> ：默认值为 true 。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类 型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认 true 关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。  </li></ul><h2 id="3-4-基本使用"><a href="#3-4-基本使用" class="headerlink" title="3.4  基本使用"></a>3.4  基本使用</h2><p> PageHelper的基本使用有6种，大家可以查看文档，最常用的有两种 </p><p>  <strong>RowBounds方式的调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Country&gt; list = sqlSession.selectList(<span class="string">"x.y.selectIf"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> RowBounds(<span class="number">1</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>使用这种调用方式时，你可以使用RowBounds参数进行分页，这种方式侵入性最小，我们可以看到，通过 RowBounds方式调用只是使用了这个参数，并没有增加其他任何内容。 分页插件检测到使用了RowBounds参数时，就会对该查询进行物理分页。 关于这种方式的调用，有两个特殊的参数是针对 RowBounds 的，你可以参看上面的分页插件参数介绍 </p><p>注：不只有命名空间方式可以用RowBounds，使用接口的时候也可以增加RowBounds参数，例如：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种情况下也会进行物理分页查询</span></span><br><span class="line"><span class="function">List&lt;Country&gt; <span class="title">selectAll</span><span class="params">(RowBounds rowBounds)</span></span>;</span><br></pre></td></tr></table></figure><p>  <strong>PageHelper.startPage 静态方法调用（重点）</strong> </p><p>在你需要进行分页的 MyBatis 查询方法前调用PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第1页，10条内容，默认查询总数count</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//紧跟着的第一个select方法会被分页</span></span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="4-Spring-Security概述"><a href="#4-Spring-Security概述" class="headerlink" title="4. Spring Security概述"></a>4. Spring Security概述</h1><h2 id="4-1-Spring-Security介绍"><a href="#4-1-Spring-Security介绍" class="headerlink" title="4.1  Spring Security介绍"></a>4.1  Spring Security介绍</h2><p>Spring Security 的前身是 Acegi Security ，是 Spring 项目组中用来提供安全认证服务的框架。 (<a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">https://projects.spring.io/spring-security/</a>) Spring Security 为基于J2EE企业应用软件提供了全面安全服务。特别 是使用领先的J2EE解决方案-Spring框架开发的企业软件项目。人们使用Spring Security有很多种原因，不过通常吸 引他们的是在J2EE Servlet规范或EJB规范中找不到典型企业应用场景的解决方案。 特别要指出的是他们不能再 WAR 或 EAR 级别进行移植。这样，如果你更换服务器环境，就要，在新的目标环境进行大量的工作，对你的应用 系统进行重新配 置安全。使用Spring Security 解决了这些问题，也为你提供很多有用的，完全可以指定的其他安 全特性。 安全包括两个主要操作。 </p><ul><li><p>“认证”，是为用户建立一个他所声明的主体。主题一般式指用户，设备或可以在你系 统中执行动作的其他系 统。 </p></li><li><p>“授权”指的是一个用户能否在你的应用中执行某个操作，在到达授权判断之前，身份的主题已经由 身份验证 过程建立了。 </p></li></ul><p>这些概念是通用的，不是Spring Security特有的。在身份验证层面，Spring Security广泛支持各种身份验证模式， 这些验证模型绝大多数都由第三方提供，或则正在开发的有关标准机构提供的，例如 Internet Engineering Task Force.作为补充，Spring Security 也提供了自己的一套验证功能。 Spring Security 目前支持认证一体化如下认证技术： HTTP BASIC authentication headers (一个基于IEFT RFC 的 标准) HTTP Digest authentication headers (一个基于IEFT RFC 的标准) HTTP X.509 client certificate exchange (一个基于IEFT RFC 的标准) LDAP (一个非常常见的跨平台认证需要做法，特别是在大环境) Form-based authentication (提供简单用户接口的需求) OpenID authentication Computer Associates Siteminder JA-SIG Central Authentication Service (CAS，这是一个流行的开源单点登录系统) Transparent authentication context propagation for Remote Method Invocation and HttpInvoker (一个Spring远程调用协议) </p><p> <strong>Maven依赖</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="4-2-Spring-Security快速入门"><a href="#4-2-Spring-Security快速入门" class="headerlink" title="4.2 Spring Security快速入门"></a>4.2 Spring Security快速入门</h2><p>  <strong>web.xml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">springSecurityFilterChain</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">DelegatingFilterProxy</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">springSecurityFilterChain</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-3-spring-security配置"><a href="#4-3-spring-security配置" class="headerlink" title="4.3  spring security配置"></a>4.3  spring security配置</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:security=<span class="string">"http://www.springframework.org/schema/security"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/security</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span><br><span class="line">    &lt;security:http auto-config=<span class="string">"true"</span> use-expressions=<span class="string">"false"</span>&gt;</span><br><span class="line">    &lt;!-- intercept-url定义一个过滤规则 pattern表示对哪些url进行权限控制，ccess属性表示在请求对应</span><br><span class="line">    的URL时需要什么权限，</span><br><span class="line">    默认配置时它应该是一个以逗号分隔的角色列表，请求的用户只需拥有其中的一个角色就能成功访问对应</span><br><span class="line">    的URL --&gt;</span><br><span class="line">    &lt;security:intercept-url pattern=<span class="string">"/**"</span> access=<span class="string">"ROLE_USER"</span> /&gt;</span><br><span class="line">    &lt;!-- auto-config配置后，不需要在配置下面信息 &lt;security:form-login /&gt; 定义登录表单信息</span><br><span class="line">    &lt;security:http-basic</span><br><span class="line">    /&gt; &lt;security:logout /&gt; --&gt;</span><br><span class="line">    &lt;/security:http&gt;</span><br><span class="line">    &lt;security:authentication-manager&gt;</span><br><span class="line">        &lt;security:authentication-provider&gt;</span><br><span class="line">            &lt;security:user-service&gt;</span><br><span class="line">                &lt;security:user name=<span class="string">"user"</span> password=<span class="string">"&#123;noop&#125;user"</span></span><br><span class="line">                authorities=<span class="string">"ROLE_USER"</span> /&gt;</span><br><span class="line">                &lt;security:user name=<span class="string">"admin"</span> password=<span class="string">"&#123;noop&#125;admin"</span></span><br><span class="line">                authorities=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><br><span class="line">            &lt;/security:user-service&gt;</span><br><span class="line">        &lt;/security:authentication-provider&gt;</span><br><span class="line">    &lt;/security:authentication-manager&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="4-4-使用自定义页面"><a href="#4-4-使用自定义页面" class="headerlink" title="4.4 使用自定义页面"></a>4.4 使用自定义页面</h2><p> <strong>spring-security.xml配置</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:security=<span class="string">"http://www.springframework.org/schema/security"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/security</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/security/spring-security.xsd"</span>&gt;</span><br><span class="line">&lt;!-- 配置不过滤的资源（静态资源及登录相关） --&gt;</span><br><span class="line">&lt;security:http security=<span class="string">"none"</span> pattern=<span class="string">"/login.html"</span> /&gt;</span><br><span class="line">&lt;security:http security=<span class="string">"none"</span> pattern=<span class="string">"/failer.html"</span> /&gt;</span><br><span class="line">&lt;security:http auto-config=<span class="string">"true"</span> use-expressions=<span class="string">"false"</span>&gt;</span><br><span class="line">&lt;!-- 配置资料连接，表示任意路径都需要ROLE_USER权限 --&gt;</span><br><span class="line">&lt;security:intercept-url pattern=<span class="string">"/**"</span> access=<span class="string">"ROLE_USER"</span> /&gt;</span><br><span class="line">&lt;!-- 自定义登陆页面，login-page 自定义登陆页面 authentication-failure-url 用户权限校验失败之</span><br><span class="line">后才会跳转到这个页面，如果数据库中没有这个用户则不会跳转到这个页面。</span><br><span class="line"><span class="keyword">default</span>-target-url 登陆成功后跳转的页面。 注：登陆页面用户名固定 username，密码</span><br><span class="line">password，action:login --&gt;</span><br><span class="line">&lt;security:form-login login-page=<span class="string">"/login.html"</span></span><br><span class="line">login-processing-url=<span class="string">"/login"</span> username-parameter=<span class="string">"username"</span></span><br><span class="line">password-parameter=<span class="string">"password"</span> authentication-failure-url=<span class="string">"/failer.html"</span></span><br><span class="line"><span class="keyword">default</span>-target-url=<span class="string">"/success.html"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 登出， invalidate-session 是否删除session logout-url：登出处理链接 logout-successurl：登出成功页面</span><br><span class="line">注：登出操作 只需要链接到 logout即可登出当前用户 --&gt;</span><br><span class="line">&lt;security:logout invalidate-session=<span class="string">"true"</span> logout-url=<span class="string">"/logout"</span></span><br><span class="line">logout-success-url=<span class="string">"/login.jsp"</span> /&gt;</span><br><span class="line">&lt;!-- 关闭CSRF,默认是开启的 --&gt;</span><br><span class="line">&lt;security:csrf disabled=<span class="string">"true"</span> /&gt;</span><br><span class="line">&lt;/security:http&gt;</span><br><span class="line">&lt;security:authentication-manager&gt;</span><br><span class="line">&lt;security:authentication-provider&gt;</span><br><span class="line">&lt;security:user-service&gt;</span><br><span class="line">&lt;security:user name=<span class="string">"user"</span> password=<span class="string">"&#123;noop&#125;user"</span></span><br><span class="line">authorities=<span class="string">"ROLE_USER"</span> /&gt;</span><br><span class="line">&lt;security:user name=<span class="string">"admin"</span> password=<span class="string">"&#123;noop&#125;admin"</span></span><br><span class="line">authorities=<span class="string">"ROLE_ADMIN"</span> /&gt;</span><br><span class="line">&lt;/security:user-service&gt;</span><br><span class="line">&lt;/security:authentication-provider&gt;</span><br><span class="line">&lt;/security:authentication-manager&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="4-5-Spring-Security使用数据库认证"><a href="#4-5-Spring-Security使用数据库认证" class="headerlink" title="4.5  Spring Security使用数据库认证"></a>4.5  Spring Security使用数据库认证</h2><p> 在Spring Security中如果想要使用数据进行认证操作，有很多种操作方式，这里我们介绍使用UserDetails、 UserDetailsService来完成操作。 </p><ul><li>UserDetails </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> UserDetails是一个接口，我们可以认为UserDetails作用是于封装当前进行认证的用户信息，但由于其是一个 接口，所以我们可以对其进行实现，也可以使用Spring Security提供的一个UserDetails的实现类User来完成 操作 </p><p>以下是User类的部分代码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span>, <span class="title">CredentialsContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GrantedAuthority&gt; authorities;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accountNonExpired; <span class="comment">//帐户是否过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accountNonLocked; <span class="comment">//帐户是否锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> credentialsNonExpired; <span class="comment">//认证是否过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enabled; <span class="comment">//帐户是否可用</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p> <strong>UserDetailsService</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-具体如何完成Spring-Security的数据库认证操作"><a href="#4-6-具体如何完成Spring-Security的数据库认证操作" class="headerlink" title="4.6  具体如何完成Spring Security的数据库认证操作"></a>4.6  具体如何完成Spring Security的数据库认证操作</h2><p> 通过用户管理中用户登录来完成<strong>Spring Security</strong>的认证操作。 </p><p> <strong>spring security的配置</strong> </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;security:authentication-manager&gt;</span><br><span class="line">    &lt;security:authentication-provider user-service-ref=<span class="string">"userService"</span>&gt;</span><br><span class="line">        &lt;!-- 配置加密的方式</span><br><span class="line">        &lt;security:password-encoder ref=<span class="string">"passwordEncoder"</span>/&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">    &lt;/security:authentication-provider&gt;</span><br><span class="line">&lt;/security:authentication-manager&gt;</span><br></pre></td></tr></table></figure><p> <strong>Service</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> <span class="keyword">extends</span> <span class="title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">UserInfo userInfo = userDao.findByUsername(username);</span><br><span class="line">List&lt;Role&gt; roles = userInfo.getRoles();</span><br><span class="line">List&lt;SimpleGrantedAuthority&gt; authoritys = getAuthority(roles);</span><br><span class="line">User user = <span class="keyword">new</span> User(userInfo.getUsername(), <span class="string">"&#123;noop&#125;"</span> + userInfo.getPassword(),</span><br><span class="line">userInfo.getStatus() == <span class="number">0</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, authoritys);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SimpleGrantedAuthority&gt; <span class="title">getAuthority</span><span class="params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">List&lt;SimpleGrantedAuthority&gt; authoritys = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">authoritys.add(<span class="keyword">new</span> SimpleGrantedAuthority(role.getRoleName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> authoritys;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用spring security完成用户退出，非常简单 </p><p><strong>配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;security:logout invalidate-session=<span class="string">"true"</span> logout-url=<span class="string">"/logout.do"</span> logout-successurl=<span class="string">"/login.jsp"</span> /&gt;</span><br></pre></td></tr></table></figure><p><strong>页面</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"$&#123;pageContext.request.contextPath&#125;/logout.do"</span></span><br><span class="line">class="btn btn-default btn-flat"&gt;注销&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="4-7-服务器端方法级权限控制"><a href="#4-7-服务器端方法级权限控制" class="headerlink" title="4.7  服务器端方法级权限控制"></a>4.7  服务器端方法级权限控制</h2><p> 在服务器端我们可以通过Spring security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上 支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要 单独通过global-method-security元素的对应属性进行启用  </p><h3 id="开启注解使用"><a href="#开启注解使用" class="headerlink" title="开启注解使用"></a><strong>开启注解使用</strong></h3><ul><li>配置文件 </li></ul><p>&lt;security:global-method-security jsr250-annotations=”enabled”/&gt;<br>&lt;security:global-method-security secured-annotations=”enabled”/&gt;<br>&lt;security:global-method-security pre-post-annotations=”disabled”/&gt;</p><ul><li><p>注解开启  </p><p>@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承 WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将 AuthenticationManager定义为Bean。 </p></li></ul><h3 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h3><ul><li>@RolesAllowed表示访问对应方法时所应该具有的角色  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="meta">@RolesAllowed</span>(&#123;<span class="string">"USER"</span>, <span class="string">"ADMIN"</span>&#125;) 该方法只要具有<span class="string">"USER"</span>, <span class="string">"ADMIN"</span>任意一种权限就可以访问。这里可以省</span><br><span class="line">略前缀ROLE_，实际的权限可能是ROLE_ADMIN</span><br></pre></td></tr></table></figure><ul><li><p>@PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制</p></li><li><p>@DenyAll是和PermitAll相反的，表示无论什么角色都不能访问  </p></li></ul><h3 id="支持表达式的注解"><a href="#支持表达式的注解" class="headerlink" title="支持表达式的注解"></a>支持表达式的注解</h3><ul><li>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changePassword</span><span class="params">(@P(<span class="string">"userId"</span>)</span> <span class="keyword">long</span> userId )</span>&#123; &#125;</span><br><span class="line">这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的</span><br><span class="line">userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该方法。</span><br></pre></td></tr></table></figure><ul><li>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="meta">@PostAuthorize</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(<span class="string">"returnObject.userId == authentication.principal.userId or</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">hasPermission(returnObject, 'ADMIN')"</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果 </p></li><li><p>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值 </p></li></ul><h3 id="Secured注解"><a href="#Secured注解" class="headerlink" title="@Secured注解"></a>@Secured注解</h3><ul><li>@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="meta">@Secured</span>(<span class="string">"IS_AUTHENTICATED_ANONYMOUSLY"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">readAccount</span><span class="params">(Long id)</span></span>;</span><br><span class="line"><span class="meta">@Secured</span>(<span class="string">"ROLE_TELLER"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(七)</title>
      <link href="/2020/02/08/Java%E5%9F%BA%E7%A1%80-%E4%B8%83/"/>
      <url>/2020/02/08/Java%E5%9F%BA%E7%A1%80-%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java复习，本篇主要复习了File类，递归，IO流，序列化等。</p> <a id="more"></a><h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。</li><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">"D:\\aaa.txt"</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">"D:\\aaa\\bbb.txt"</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">"d:\\aaa"</span>;</span><br><span class="line"> String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">String child = <span class="string">"bbb.txt"</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建</li></ol></blockquote><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p></li><li><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:/aaa/bbb.java"</span>);     </span><br><span class="line">        System.out.println(<span class="string">"文件绝对路径:"</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"文件构造路径:"</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">"文件名称:"</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">"文件长度:"</span>+f.length()+<span class="string">"字节"</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:/aaa"</span>);     </span><br><span class="line">        System.out.println(<span class="string">"目录绝对路径:"</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"目录构造路径:"</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">"目录名称:"</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">"目录长度:"</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:\\aaa\\bbb.java"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa\\bbb.java 是否存在:"</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 是否存在:"</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 文件?:"</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 目录?:"</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"aaa.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> File(<span class="string">"newDir"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><p><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</p></li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><h2 id="2-2-练习—递归求阶乘"><a href="#2-2-练习—递归求阶乘" class="headerlink" title="2.2  练习—递归求阶乘"></a>2.2  练习—递归求阶乘</h2><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">      <span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="keyword">int</span> value = getValue(n);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"阶乘为:"</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过递归算法实现.</span></span><br><span class="line"><span class="comment">    参数列表:int </span></span><br><span class="line"><span class="comment">    返回值类型: int </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三章-IO概述"><a href="#第三章-IO概述" class="headerlink" title="第三章 IO概述"></a>第三章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h2 id="1-3-顶级父类们"><a href="#1-3-顶级父类们" class="headerlink" title="1.3 顶级父类们"></a>1.3 顶级父类们</h2><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br /><strong>InputStream</strong></td><td align="center">字节输出流<br /><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br /><strong>Reader</strong></td><td align="center">字符输出流<br /><strong>Writer</strong></td></tr></tbody></table><h1 id="第四章-字节流"><a href="#第四章-字节流" class="headerlink" title="第四章 字节流"></a>第四章 字节流</h1><h2 id="4-1-一切皆为字节"><a href="#4-1-一切皆为字节" class="headerlink" title="4.1 一切皆为字节"></a>4.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h2 id="4-2-字节输出流【OutputStream】"><a href="#4-2-字节输出流【OutputStream】" class="headerlink" title="4.2 字节输出流【OutputStream】"></a>4.2 字节输出流【OutputStream】</h2><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><h2 id="4-3-FileOutputStream类"><a href="#4-3-FileOutputStream类" class="headerlink" title="4.3 FileOutputStream类"></a>4.3 FileOutputStream类</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</li></ul><h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据</li><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据</li><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节</li></ol><h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。</p><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul><h2 id="4-4-字节输入流【InputStream】"><a href="#4-4-字节输入流【InputStream】" class="headerlink" title="4.4 字节输入流【InputStream】"></a>4.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><h2 id="4-5-FileInputStream类"><a href="#4-5-FileInputStream类" class="headerlink" title="4.5 FileInputStream类"></a>4.5 FileInputStream类</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol><li><p><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code></p><p>循环改进读取方式，代码使用演示：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为int类型。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> </li></ol><h1 id="第五章-字符流"><a href="#第五章-字符流" class="headerlink" title="第五章 字符流"></a>第五章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="5-1-字符输入流【Reader】"><a href="#5-1-字符输入流【Reader】" class="headerlink" title="5.1 字符输入流【Reader】"></a>5.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h2 id="5-2-FileReader类"><a href="#5-2-FileReader类" class="headerlink" title="5.2 FileReader类"></a>5.2 FileReader类</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code></li><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> </li></ol><h2 id="5-3-字符输出流【Writer】"><a href="#5-3-字符输出流【Writer】" class="headerlink" title="5.3 字符输出流【Writer】"></a>5.3 字符输出流【Writer】</h2><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str)</code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h2 id="5-4-FileWriter类"><a href="#5-4-FileWriter类" class="headerlink" title="5.4 FileWriter类"></a>5.4 FileWriter类</h2><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据</p><h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream</li><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</li></ol><h1 id="第六章-缓冲流"><a href="#第六章-缓冲流" class="headerlink" title="第六章 缓冲流"></a>第六章 缓冲流</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h2 id="6-2-字节缓冲流"><a href="#6-2-字节缓冲流" class="headerlink" title="6.2 字节缓冲流"></a>6.2 字节缓冲流</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure><h2 id="6-3-字符缓冲流"><a href="#6-3-字符缓冲流" class="headerlink" title="6.3 字符缓冲流"></a>6.3 字符缓冲流</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"br.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br></pre></td></tr></table></figure><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><h1 id="第七章-转换流"><a href="#第七章-转换流" class="headerlink" title="第七章 转换流"></a>第七章 转换流</h1><h2 id="7-1-InputStreamReader类"><a href="#7-1-InputStreamReader类" class="headerlink" title="7.1 InputStreamReader类"></a>7.1 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><h2 id="7-2-OutputStreamWriter类"><a href="#7-2-OutputStreamWriter类" class="headerlink" title="7.2 OutputStreamWriter类"></a>7.2 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><h1 id="第八章-序列化"><a href="#第八章-序列化" class="headerlink" title="第八章 序列化"></a>第八章 序列化</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化：</p><h2 id="8-2-ObjectOutputStream类"><a href="#8-2-ObjectOutputStream类" class="headerlink" title="8.2 ObjectOutputStream类"></a>8.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure><ul><li><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">    e.age = <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        out.writeObject(e);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-3-ObjectInputStream类"><a href="#8-3-ObjectInputStream类" class="headerlink" title="8.3 ObjectInputStream类"></a>8.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h3 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础(七) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(六)</title>
      <link href="/2020/02/08/Java%E5%9F%BA%E7%A1%80-%E5%85%AD/"/>
      <url>/2020/02/08/Java%E5%9F%BA%E7%A1%80-%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java复习！主要内容有异常，线程，同步，Lambda表达式等。</p> <a id="more"></a><h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章 异常"></a>第一章 异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1 抛出异常throw"></a>2.1 抛出异常throw</h2><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type"></span>异常类名(参数);</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure><h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><ul><li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3 声明异常throws"></a>2.3 声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4 捕获异常try…catch"></a>2.4 捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><h2 id="2-5-finally代码块"><a href="#2-5-finally代码块" class="headerlink" title="2.5 finally代码块"></a>2.5 finally代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><h2 id="2-6-异常注意事项"><a href="#2-6-异常注意事项" class="headerlink" title="2.6 异常注意事项"></a>2.6 异常注意事项</h2><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote><h1 id="第三章-多线程"><a href="#第三章-多线程" class="headerlink" title="第三章 多线程"></a>第三章 多线程</h1><h2 id="3-1-并发与并行"><a href="#3-1-并发与并行" class="headerlink" title="3.1 并发与并行"></a>3.1 并发与并行</h2><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。(不会同时发生)</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><h2 id="3-2-线程与进程"><a href="#3-2-线程与进程" class="headerlink" title="3.2 线程与进程"></a>3.2 线程与进程</h2><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p></li></ul><h2 id="3-3-创建线程类"><a href="#3-3-创建线程类" class="headerlink" title="3.3 创建线程类"></a>3.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><h2 id="3-4-多线程原理"><a href="#3-4-多线程原理" class="headerlink" title="3.4 多线程原理"></a>3.4 多线程原理</h2><p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 </p><p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。  当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了 </p><h2 id="3-5-Thread类"><a href="#3-5-Thread类" class="headerlink" title="3.5 Thread类"></a>3.5 Thread类</h2><p><strong>构造方法：</strong> </p><ul><li><p>public Thread(String name) :分配一个指定名字的新的线程对象。 </p></li><li><p>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。 </p></li><li><p>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 </p></li></ul><p><strong>常用方法：</strong> </p><ul><li><p>public String getName() :获取当前线程名称。 </p></li><li><p>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。 </p></li><li><p>public void run() :此线程要执行的任务在此处定义代码。 </p></li><li><p>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 </p></li><li><p>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 </p><p><strong>创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式</strong> </p></li></ul><h2 id="3-6-创建线程方式二—实现Runnable接口"><a href="#3-6-创建线程方式二—实现Runnable接口" class="headerlink" title="3.6 创建线程方式二—实现Runnable接口"></a>3.6 创建线程方式二—实现Runnable接口</h2><p><strong>重写run方法即可</strong></p><p>步骤如下： </p><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 </li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正 的线程对象。 </li><li>调用线程对象的start()方法来启动线程。 </li></ol><h2 id="3-7-Thread和Runnable的区别"><a href="#3-7-Thread和Runnable的区别" class="headerlink" title="3.7  Thread和Runnable的区别"></a>3.7  Thread和Runnable的区别</h2><p> 如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 </p><p><strong>总结</strong></p><p> <strong>实现Runnable接口比继承Thread类所具有的优势：</strong> </p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。 </li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 </li></ol><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。 </p><h1 id="第四章-线程安全"><a href="#第四章-线程安全" class="headerlink" title="第四章 线程安全"></a>第四章 线程安全</h1><h2 id="4-1-线程安全"><a href="#4-1-线程安全" class="headerlink" title="4.1 线程安全"></a>4.1 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 </p><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。  </p><h2 id="4-2-线程同步"><a href="#4-2-线程同步" class="headerlink" title="4.2 线程同步"></a>4.2 线程同步</h2><p> 当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (<strong>synchronized</strong>)来解决。 </p><p> 有三种方式完成同步操作： </p><ol><li><p><strong>同步代码块。</strong> </p></li><li><p><strong>同步方法。</strong></p></li><li><p><strong>锁机制。</strong>  </p></li></ol><h2 id="4-3-线程同步三个方法—–同步代码块"><a href="#4-3-线程同步三个方法—–同步代码块" class="headerlink" title="4.3 线程同步三个方法—–同步代码块"></a>4.3 线程同步三个方法—–同步代码块</h2><ul><li><p><strong>同步代码块：</strong> synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><p>格式: </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>同步锁:</strong></p><p> 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. </p><ol><li>锁对象 可以是任意类型。 </li><li>多个线程对象 要使用同一把锁。  </li></ol><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)。 </p><h2 id="4-4-线程同步三个方法—–同步方法"><a href="#4-4-线程同步三个方法—–同步方法" class="headerlink" title="4.4 线程同步三个方法—–同步方法"></a>4.4 线程同步三个方法—–同步方法</h2><ul><li><p><strong>同步方法:</strong>使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外 等着。  </p><p>格式： </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-Lock锁"><a href="#4-5-Lock锁" class="headerlink" title="4.5 Lock锁"></a>4.5 Lock锁</h2><p> Lock锁也称同步锁，加锁与释放锁方法化了，如下： </p><ul><li>public void lock() :加同步锁。 </li><li>public void unlock() :释放同步锁。 </li></ul><h1 id="第五章-线程状态"><a href="#第五章-线程状态" class="headerlink" title="第五章 线程状态"></a>第五章 线程状态</h1><h2 id="5-1-线程状态概述"><a href="#5-1-线程状态概述" class="headerlink" title="5.1 线程状态概述"></a>5.1 线程状态概述</h2><table><thead><tr><th>线程状态</th><th>导致状态发生条件</th></tr></thead><tbody><tr><td>NEW(新建)</td><td>线程刚被创建，但是并未启动。还没调用start方法</td></tr><tr><td>Runnable(可运行)</td><td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。</td></tr><tr><td>Blocked(锁阻塞)</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>Waiting(无限等待)</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td></tr><tr><td>Timed Waiting(计时等待)</td><td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。</td></tr><tr><td>Teminated(被 终止)</td><td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h2 id="5-2-Timed-Waiting（计时等待）"><a href="#5-2-Timed-Waiting（计时等待）" class="headerlink" title="5.2  Timed Waiting（计时等待）"></a>5.2  Timed Waiting（计时等待）</h2><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协 作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程 中会睡眠 </li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 </li></ol><p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就 开始立刻执行。 </p><h2 id="5-3-BLOCKED（锁阻塞）"><a href="#5-3-BLOCKED（锁阻塞）" class="headerlink" title="5.3  BLOCKED（锁阻塞）"></a>5.3  BLOCKED（锁阻塞）</h2><p>线程A与线程B代码中使用同一锁，如果线程A获 取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 </p><h2 id="5-4-Waiting（无限等待）"><a href="#5-4-Waiting（无限等待）" class="headerlink" title="5.4  Waiting（无限等待）"></a>5.4  Waiting（无限等待）</h2><p>A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 </p><h1 id="第六章-等待唤醒机制"><a href="#第六章-等待唤醒机制" class="headerlink" title="第六章 等待唤醒机制"></a>第六章 等待唤醒机制</h1><h2 id="6-1-线程间通信"><a href="#6-1-线程间通信" class="headerlink" title="6.1 线程间通信"></a>6.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p><p><strong>为什么要处理线程间通信：</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h2 id="6-2-等待唤醒机制"><a href="#6-2-等待唤醒机制" class="headerlink" title="6.2 等待唤醒机制"></a>6.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait()</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><p><strong>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</strong></p><h1 id="第七章-线程池"><a href="#第七章-线程池" class="headerlink" title="第七章 线程池"></a>第七章 线程池</h1><h2 id="7-1-线程池概念"><a href="#7-1-线程池概念" class="headerlink" title="7.1 线程池概念"></a>7.1 线程池概念</h2><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p><strong>合理利用线程池能够带来好处：</strong></p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h2 id="7-2-线程池的使用"><a href="#7-2-线程池的使用" class="headerlink" title="7.2 线程池的使用"></a>7.2 线程池的使用</h2><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，怎么使用，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><h1 id="第八章-Lambda表达式"><a href="#第八章-Lambda表达式" class="headerlink" title="第八章 Lambda表达式"></a>第八章 Lambda表达式</h1><h2 id="8-1-函数式编程思想概述"><a href="#8-1-函数式编程思想概述" class="headerlink" title="8.1 函数式编程思想概述"></a>8.1 函数式编程思想概述</h2><p><strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="8-2-编程思想转换"><a href="#8-2-编程思想转换" class="headerlink" title="8.2 编程思想转换"></a>8.2 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h2 id="8-3-Lambda标准格式"><a href="#8-3-Lambda标准格式" class="headerlink" title="8.3 Lambda标准格式"></a>8.3 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(参数类型 参数名称)</span> -&gt;</span> &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础(六) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(五)</title>
      <link href="/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E4%BA%94/"/>
      <url>/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java复习主要内容：Collection集合，迭代器，增强for（for-each），泛型，List集合，Set集合，Collections集合工具类，Map集合。</p> <a id="more"></a><h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2 集合框架"></a>1.2 集合框架</h2><p>集合按照其存储结构可以分为两大类:</p><p>分别是<strong>单列集合</strong><code>java.util.Collection</code>和<strong>双列集合</strong><code>java.util.Map</code></p><p><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是<strong>元素有序、元素可重复</strong>。<code>Set</code>的特点是<strong>元素无序，而且不可重复</strong>。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h1 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h1><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p><code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p><strong>迭代的概念</strong></p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="3-2-泛型的定义和使用"><a href="#3-2-泛型的定义和使用" class="headerlink" title="3.2 泛型的定义和使用"></a>3.2 泛型的定义和使用</h2><p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 类名&lt;代表泛型的变量&gt; &#123;</span>  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">修饰符 <span class="tag">&lt;<span class="name">代表泛型的变量</span>&gt;</span> 返回值类型 方法名(参数)</span><span class="template-variable">&#123;  &#125;</span></span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span>接口名&lt;代表泛型的变量&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><h2 id="3-3-泛型通配符"><a href="#3-3-泛型通配符" class="headerlink" title="3.3 泛型通配符"></a>3.3 泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用.</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>举例：</p><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-List集合"><a href="#第四章-List集合" class="headerlink" title="第四章 List集合"></a>第四章 List集合</h1><h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p>在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，<strong>List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致</strong>。</p><p><strong>List接口特点：</strong></p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><h1 id="第五章-List的子类"><a href="#第五章-List的子类" class="headerlink" title="第五章 List的子类"></a>第五章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合，查询慢，增删快。</p><p>方法：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><h1 id="第六章-Set接口"><a href="#第六章-Set接口" class="headerlink" title="第六章 Set接口"></a>第六章 Set接口</h1><p><strong>Set</strong>接口与<strong>List</strong>接口一样，同样继承<strong>Collection</strong>接口，与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，不重复的，并且都会以某种规则保证存入的元素不出现重复。</p><p>Set集合取出元素的方式可以采用：迭代器、增强for。</p><h2 id="6-1-HashSet集合"><a href="#6-1-HashSet集合" class="headerlink" title="6.1 HashSet集合"></a>6.1 HashSet集合</h2><p><code>HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)，<code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><h2 id="6-2-HashSet集合存储数据的结构（哈希表）"><a href="#6-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="6.2 HashSet集合存储数据的结构（哈希表）"></a>6.2 HashSet集合存储数据的结构（哈希表）</h2><p><strong>什么是哈希表呢？</strong></p><p>哈希表就是一种以 键-值(key-value ) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。 </p><p>在JDK1.8中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的</p><p><strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式</p><h2 id="6-3-HashSet存储自定义类型元素"><a href="#6-3-HashSet存储自定义类型元素" class="headerlink" title="6.3 HashSet存储自定义类型元素"></a>6.3 HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><h2 id="6-4-LinkedHashSet"><a href="#6-4-LinkedHashSet" class="headerlink" title="6.4 LinkedHashSet"></a>6.4 LinkedHashSet</h2><p>HashSet可以保证元素唯一，但是元素存放是无序的，而需要有序的是在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><h1 id="第七章-Collections"><a href="#第七章-Collections" class="headerlink" title="第七章 Collections"></a>第七章 Collections</h1><h2 id="7-1-常用功能"><a href="#7-1-常用功能" class="headerlink" title="7.1 常用功能"></a>7.1 常用功能</h2><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><h1 id="第八章-Map集合"><a href="#第八章-Map集合" class="headerlink" title="第八章 Map集合"></a>第八章 Map集合</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><ul><li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h2 id="8-2-Map常用子类"><a href="#8-2-Map常用子类" class="headerlink" title="8.2  Map常用子类"></a>8.2  Map常用子类</h2><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap&lt;K,V&gt;</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><h2 id="8-3-Map接口中的常用方法"><a href="#8-3-Map接口中的常用方法" class="headerlink" title="8.3 Map接口中的常用方法"></a>8.3 Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="8-4-Map集合遍历键找值方式"><a href="#8-4-Map集合遍历键找值方式" class="headerlink" title="8.4 Map集合遍历键找值方式"></a>8.4 Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          <span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"的CP是："</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-5-Entry键值对对象"><a href="#8-5-Entry键值对对象" class="headerlink" title="8.5  Entry键值对对象"></a>8.5  Entry键值对对象</h2><p><code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。</p><p>Entry表示了一对键和值，提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h2 id="8-6-Map集合遍历键值对方式"><a href="#8-6-Map集合遍历键值对方式" class="headerlink" title="8.6 Map集合遍历键值对方式"></a>8.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           <span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">"的CP是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-7-HashMap存储自定义类型键值"><a href="#8-7-HashMap存储自定义类型键值" class="headerlink" title="8.7 HashMap存储自定义类型键值"></a>8.7 HashMap存储自定义类型键值</h2><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li></ul><h2 id="8-8-LinkedHashMap"><a href="#8-8-LinkedHashMap" class="headerlink" title="8.8   LinkedHashMap"></a>8.8   LinkedHashMap</h2><p><strong>LinkedHashMap</strong>保证有序即map中存放的key和取出的顺序一致，它是链表和哈希表组合的一个数据存储结构。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础(五) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(四)</title>
      <link href="/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E5%9B%9B/"/>
      <url>/2020/02/06/Java%E5%9F%BA%E7%A1%80-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java基础复习，Object类和常用API，主要内容有：Object类，Object类，DateFormat类，Calendar类，System类，StringBuilder类，包装类。</p> <a id="more"></a><h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h2><table><thead><tr><th>方法</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>clone()</td><td>创建并返回此对象的副本</td><td>Object</td></tr><tr><td>equals(Object obj)</td><td>指示一些其他对象是否等于此</td><td>boolen</td></tr><tr><td>finalize()</td><td>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象</td><td>void</td></tr><tr><td>getClass()</td><td>返回此 <code>Object</code>的运行时类。</td><td>类&lt;?&gt;</td></tr><tr><td>hashCode()</td><td>返回对象的哈希码值。</td><td>int</td></tr><tr><td>notify()</td><td>唤醒正在等待对象监视器的单个线程。</td><td>void</td></tr><tr><td>notifyAll()</td><td>唤醒正在等待对象监视器的所有线程。</td><td>void</td></tr><tr><td>toString()</td><td>返回对象的字符串表示形式。</td><td>String</td></tr><tr><td>wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td><td>void</td></tr><tr><td>wait(long timeout)</td><td>导致当前线程等待，直到另一个线程调用 notify()方法或该对象的 notifyAll()方法，或者指定的时间已过。</td><td>void</td></tr><tr><td>wait(long timeout, int nanos)</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，或一定量的实时时间</td><td>void</td></tr></tbody></table><p><strong>Object类当中包含的方法有11个。</strong>其中最为常见的为</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-3-toString-方法"><a href="#1-3-toString-方法" class="headerlink" title="1.3 toString 方法"></a>1.3 toString 方法</h2><h3 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-equals方法"><a href="#1-4-equals方法" class="headerlink" title="1.4 equals方法"></a>1.4 equals方法</h2><h3 id="方法说明-1"><a href="#方法说明-1" class="headerlink" title="方法说明"></a>方法说明</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-补充"><a href="#1-5-补充" class="headerlink" title="1.5 补充"></a>1.5 补充</h2><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><ul><li><p><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</p></li><li><p><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</p></li><li><p><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</p></li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，可以完成完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h2 id="2-3-Calendar类"><a href="#2-3-Calendar类" class="headerlink" title="2.3 Calendar类"></a>2.3 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h2 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h2><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h3 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h3><p>currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h3><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Hello"</span>;</span><br><span class="line">        s += <span class="string">"World"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-概述"><a href="#4-2-概述" class="headerlink" title="4.2 概述"></a>4.2 概述</h2><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。(默认16字符空间，超过自动扩充)</p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h2 id="5-3-自动装箱与自动拆箱"><a href="#5-3-自动装箱与自动拆箱" class="headerlink" title="5.3 自动装箱与自动拆箱"></a>5.3 自动装箱与自动拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line"></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h2 id="5-4-基本类型与字符串之间的转换"><a href="#5-4-基本类型与字符串之间的转换" class="headerlink" title="5.4  基本类型与字符串之间的转换"></a>5.4  基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p><strong>基本类型转换String总共有三种方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式（最常用）</span></span><br><span class="line">String s1 = a + <span class="string">""</span>;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br><span class="line">String s2 = String.valueOf(a);</span><br><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">Integer b = a;</span><br><span class="line">String s3 = b.toString();</span><br></pre></td></tr></table></figure><p><strong>String转换成对应的基本类型</strong> </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>以Integer类的静态方法parseXxx为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础(四) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(三)</title>
      <link href="/2020/01/27/Java%E5%9F%BA%E7%A1%80-%E4%B8%89/"/>
      <url>/2020/01/27/Java%E5%9F%BA%E7%A1%80-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java基础复习，本篇博客写了继承、多态、抽象类、接口内部类、final关键字、权限修饰符，继续加油吧少年！！</p> <a id="more"></a><h1 id="第一章-继承"><a href="#第一章-继承" class="headerlink" title="第一章 继承"></a>第一章 继承</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><strong>定义</strong></p><ul><li><strong>继承：</strong> 就是子类继承父类的属性和行为，使得子类具有父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</li></ul><p><strong>好处</strong></p><ol><li>提高代码的复用性。</li><li>类与类之间产生了关系，是多态的前提。</li></ol><h2 id="1-2-继承的格式"><a href="#1-2-继承的格式" class="headerlink" title="1.2 继承的格式"></a>1.2 继承的格式</h2><p>通过extends关键字，可以声明一个子类继承另外一个父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-继承后的特点—-成员变量"><a href="#1-3-继承后的特点—-成员变量" class="headerlink" title="1.3 继承后的特点—-成员变量"></a>1.3 继承后的特点—-成员变量</h2><p><strong>成员变量不重名</strong></p><p>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的</p><p><strong>成员变量重名</strong></p><p>如果子类和父类中出现重名的成员变量时，在子类中需要访问父类中非私有成员的变量时，需要使用<strong>super</strong>关键字，修饰父类成员变量，类似于之前学过的<strong>this</strong>。</p><p>使用格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure><p>注意：父类中的成员变量是非私有的，子类中可以直接访问。若父类中的成员变量私有了，子类不可以直接访问，如果要访问父类的私有成员变量，可以在父类中提供<strong>getxxx</strong>和<strong>setxxx</strong>方法。</p><h2 id="1-4继承后的特点—-成员方法"><a href="#1-4继承后的特点—-成员方法" class="headerlink" title="1.4继承后的特点—-成员方法"></a>1.4继承后的特点—-成员方法</h2><p><strong>成员方法不重名</strong></p><p> 如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。对象调用方法时，会先在子类中查找有没有对 应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。 </p><p><strong>成员方法重名—-重写（Override）</strong></p><p>如果子类父类中出现重名的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写</strong>(Override)</p><ul><li><strong>方法重写</strong>：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都会相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现。</strong></li></ul><p><strong>注意事项</strong></p><ol><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h2 id="1-5-继承后的特点—–构造方法"><a href="#1-5-继承后的特点—–构造方法" class="headerlink" title="1.5 继承后的特点—–构造方法"></a>1.5 继承后的特点—–构造方法</h2><p><strong>构造方法定义格式和作用</strong></p><ol><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化成员变量的。 所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构 造方法中默认有一个 <strong>super()</strong> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。 </li></ol><h2 id="1-6-super和this"><a href="#1-6-super和this" class="headerlink" title="1.6 super和this"></a>1.6 super和this</h2><p><strong>父类空间优于子类对象产生</strong></p><p><strong>super和this的含义</strong></p><ul><li><strong>super</strong>：代表父类的存储空间标识（可以理解为父亲的引用）。</li><li><strong>this</strong>：代表当前对象的引用（谁调用就代表谁）。</li></ul><p><strong>super和this的用法</strong></p><ol><li><strong>访问成员</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量 ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员变量 ‐‐ 父类的</span><br><span class="line"><span class="keyword">this</span>.成员方法名() ‐‐ 本类的</span><br><span class="line"><span class="keyword">super</span>.成员方法名() ‐‐ 父类的</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>访问构造方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>(...)--本类的构造方法</span><br><span class="line"><span class="keyword">super</span>(...)--父类的构造方法</span><br></pre></td></tr></table></figure><p> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 </p><h2 id="1-7-继承的特点"><a href="#1-7-继承的特点" class="headerlink" title="1.7 继承的特点"></a>1.7 继承的特点</h2><ol><li>Java只支持单继承，不支持多继承。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125; <span class="comment">//正确</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;&#125;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Java支持多层继承</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 顶层父类是Object类。所有的类默认继承Object，作为父类。 </p><h1 id="第二章-抽象类"><a href="#第二章-抽象类" class="headerlink" title="第二章 抽象类"></a>第二章 抽象类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><strong>由来</strong></p><p> 父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。  <strong>包含抽象方法 的类就是抽象类。</strong> </p><p><strong>定义</strong></p><ul><li>抽象方法：没有方法体的方法。</li><li>抽象类：包含抽象方法的类。</li></ul><h2 id="2-2-abstract使用格式"><a href="#2-2-abstract使用格式" class="headerlink" title="2.2 abstract使用格式"></a>2.2 abstract使用格式</h2><p><strong>抽象方法</strong></p><p>使用abstract关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p><strong>定义格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表)；</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>抽象类</strong></p><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名字</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象的使用</strong></p><p> 继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父 类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。 </p><h2 id="2-3-注意事项"><a href="#2-3-注意事项" class="headerlink" title="2.3 注意事项"></a>2.3 注意事项</h2><ol><li>抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。  </li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。  </li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 </li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象 类。  </li></ol><h1 id="第三章-接口"><a href="#第三章-接口" class="headerlink" title="第三章 接口"></a>第三章 接口</h1><h2 id="1-1-概述-1"><a href="#1-1-概述-1" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p> 接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么 接口的内部主要就是封装了方法，.</p><p> 接口的定义，它与定义类方式相似，但是使用 interface 关键字。 </p><p>引用数据类型：数组，类，接口。</p><p> 接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做 是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><h2 id="1-2-定义格式"><a href="#1-2-定义格式" class="headerlink" title="1.2 定义格式"></a>1.2 定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line"><span class="comment">//默认方法</span></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有抽象方法</strong></p><p>抽象方法：使用abstract关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有默认方法和静态方法</strong></p><p>默认方法：使用default修饰，不可省略，供子类调用或者子类重写。</p><p>静态方法：使用static修饰，供接口直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>含有私有方法和私有静态方法</strong></p><p>私有方法：使用private修饰，供接口中的默认方法或者静态方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterFaceName</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-基本实现"><a href="#1-3-基本实现" class="headerlink" title="1.3 基本实现"></a>1.3 基本实现</h2><p><strong>实现的概述</strong></p><p>类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。</p><p>非抽象子类实现接口</p><ol><li>必须重写接口中所有的抽象方法</li><li>继承了接口的默认方法，即可以直接调用，也可以重写</li></ol><p>实现格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;</span><br><span class="line"><span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">// 重写接口中默认方法【可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>抽象方法的使用</strong> </p><p>必须全部实现 </p><p> <strong>默认方法的使用</strong> </p><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 </p><p> <strong>静态方法的使用</strong> </p><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 </p><p> <strong>私有方法的使用</strong> </p><ul><li><p>私有方法：只有默认方法可以调用。 </p></li><li><p>私有静态方法：默认方法和静态方法可以调用 </p></li></ul><h2 id="1-4-接口的多实现"><a href="#1-4-接口的多实现" class="headerlink" title="1.4 接口的多实现"></a>1.4 接口的多实现</h2><p>​        在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接 口的多实现。并且，一个类能继承一个父类，同时实现多个接口。 </p><p>实现格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123;</span><br><span class="line"><span class="comment">// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">// 重写接口中默认方法【不重名时可选】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象方法</strong></p><p> 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</p><p> <strong>默认方法</strong> </p><p>接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 </p><p> <strong>静态方法</strong></p><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。  </p><p> <strong>优先级的问题</strong> </p><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执 行父类的成员方法。 </p><h2 id="1-5-接口的多继承"><a href="#1-5-接口的多继承" class="headerlink" title="1.5 接口的多继承"></a>1.5 接口的多继承</h2><p> 一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继 承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次。</strong> </p><h2 id="1-6-其他成员变量"><a href="#1-6-其他成员变量" class="headerlink" title="1.6 其他成员变量"></a>1.6 其他成员变量</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 </li><li>接口中，没有构造方法，不能创建对象。 </li><li>接口中，没有静态代码块。  </li></ul><h1 id="第四章-多态"><a href="#第四章-多态" class="headerlink" title="第四章 多态"></a>第四章 多态</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p><strong>引入</strong></p><p> 多态是继封装、继承之后，面向对象的第三大特性。  </p><p><strong>定义</strong></p><p><strong>多态：</strong> 是指同一行为，具有多个不同表现形式。</p><p><strong>前提</strong></p><ol><li>继承或者实现【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li>父类引用指向子类对象【格式体现】 </li></ol><h2 id="4-2-多态的体现"><a href="#4-2-多态的体现" class="headerlink" title="4.2 多态的体现"></a>4.2 多态的体现</h2><p><strong>多态体现的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类对象；</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法。  </p><h2 id="4-3-多态的好处"><a href="#4-3-多态的好处" class="headerlink" title="4.3 多态的好处"></a>4.3 多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利 </p><h2 id="4-4-引用类型转换"><a href="#4-4-引用类型转换" class="headerlink" title="4.4 引用类型转换"></a>4.4 引用类型转换</h2><p> <strong>多态的转型分为向上转型与向下转型两种：</strong>  </p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><ul><li><strong>向上转型</strong> ： ：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 </li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型 变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转型的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 </li></ul><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类变量名;</span><br><span class="line">如:Cat c =(Cat) a;</span><br></pre></td></tr></table></figure><h3 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h3><p> 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥 有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子 类特有的方法，必须做向下转型 </p><h3 id="转型异常"><a href="#转型异常" class="headerlink" title="转型异常"></a>转型异常</h3><p> Java提供了 instanceof 关键字，给引用变量做类型的校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line">如果变量属于该数据类型，返回<span class="keyword">true</span>。</span><br><span class="line">如果变量不属于该数据类型，返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h1 id="第五章-final关键字"><a href="#第五章-final关键字" class="headerlink" title="第五章 final关键字"></a>第五章 final关键字</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>子类可以在父类的基础上改写父类内容，为了避免这种随意改写的情况，Java提供了 final 关键字， 用于修饰不可改变内容。 </p><ul><li><strong>final</strong> ：不可改变，用于修饰类，方法和变量<ul><li>类：被修饰的类，不能被继承。 </li><li>方法：被修饰的方法，不能被重写。 </li><li>变量：被修饰的变量，不能被重新赋值。 </li></ul></li></ul><h2 id="5-2-使用方式"><a href="#5-2-使用方式" class="headerlink" title="5.2 使用方式"></a>5.2 使用方式</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a><strong>修饰类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询API发现像 public final class String 、 public final class Math 、 public final class Scanner 等，很多我们学习过的类，都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。 </p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a><strong>修饰方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 重写被 final 修饰的方法，编译时就会报错 </p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><ol><li><p><strong>局部变量—-基本类型</strong></p><p> 基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改 </p></li><li><p><strong>局部变量—-引用类型</strong></p><p> 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的 修改，。</p></li><li><p><strong>成员变量</strong></p><p>成员变量涉及到初始化的问题，初始化方式有两种，只能二选一 </p></li></ol><ul><li>显示初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String USERNAME = <span class="string">"张三"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String USERNAME ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.USERNAME = username;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第六章-权限修饰符"><a href="#第六章-权限修饰符" class="headerlink" title="第六章 权限修饰符"></a>第六章 权限修饰符</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p> 在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限， </p><ul><li>public：公共的。 </li><li>protected：受保护的 </li><li>default（什么都不写）：默认的 </li><li>private：私有的 </li></ul><h2 id="6-2-不同权限的访问能力"><a href="#6-2-不同权限的访问能力" class="headerlink" title="6.2 不同权限的访问能力"></a>6.2 不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default(空的)</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>同一包中</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>不同包的子类</td><td>✔</td><td>✔</td><td></td><td></td></tr><tr><td>不同包的无关类</td><td>✔</td><td></td><td></td><td></td></tr></tbody></table><p> 可见，public具有最大权限。private则是最小权限 。</p><p>建议</p><ul><li>成员变量使用 private ，隐藏细节。 </li><li>构造方法使用 public ，方便创建对象。 </li><li>成员方法使用 public ，方便调用方法。 </li></ul><h1 id="第七章-内部类"><a href="#第七章-内部类" class="headerlink" title="第七章 内部类"></a>第七章 内部类</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><h3 id="什么是内部类"><a href="#什么是内部类" class="headerlink" title="什么是内部类"></a><strong>什么是内部类</strong></h3><p> 将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。 </p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a><strong>成员内部类</strong></h3><p> 成员内部类 ：定义在类中方法外的类。  </p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine </p><h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><ul><li>内部类可以直接访问外部类的成员，包括私有成员。</li><li>外部类要访问内部类的成员，必须要建立内部类的对象。 </li></ul><p>创建内部类对象格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类型().<span class="keyword">new</span> 内部类型()；</span><br></pre></td></tr></table></figure><h2 id="7-2-匿名内部类"><a href="#7-2-匿名内部类" class="headerlink" title="7.2 匿名内部类"></a>7.2 匿名内部类</h2><ul><li><strong>匿名内部类</strong> ： 是内部类的简化写法。它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了 </li></ul><p><strong>前提</strong></p><p> 匿名内部类必须继承一个父类或者实现一个父接口。 </p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line"><span class="comment">// 方法重写</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础(三) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础（二）</title>
      <link href="/2020/01/26/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/26/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在复习的Java基础的过程中采用写博客的方法，更有助于记忆的吸收，本篇博客总结了面向对象的思想，封装，还有常用API中Scanner类，Random类，ArrayList类，String类等，继续加油吧少年！</p>   <a id="more"></a><h1 id="第1章-面向对象思想"><a href="#第1章-面向对象思想" class="headerlink" title="第1章 面向对象思想"></a>第1章 面向对象思想</h1><h2 id="1-1面向对象思想的概述"><a href="#1-1面向对象思想的概述" class="headerlink" title="1.1面向对象思想的概述"></a>1.1面向对象思想的概述</h2><p><strong>概述</strong></p><p>​        Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计，开发计算机程序。这里的对象泛指现实中一切的事物，每种事物都具备自己的属性和行为。它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><p><strong>区别</strong></p><ul><li>面向过程：强调步骤</li><li>面向对象： 强调对象</li></ul><p><strong>特点</strong></p><p>​        面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。面向对象的语言中，包含三大基本特征，即封装、继承、多态。</p><h2 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h2><p><strong>什么是类</strong></p><ul><li><strong>类：</strong>    是一组相关属性和行为的集合。</li><li><strong>属性：</strong>就是该事物的状态信息</li><li><strong>行为：</strong> 就是该事物能做什么</li></ul><p><strong>什么是对象</strong></p><ul><li><strong>对象：</strong>是一类事物的具体表现。对象是类的一个实例，必然具备该类事物的属性和行为。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是对一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><h2 id="1-3类的定义"><a href="#1-3类的定义" class="headerlink" title="1.3类的定义"></a>1.3类的定义</h2><p><strong>类的定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>定义类：</strong> 就是定义类的成员，包括成员变量和成员方法。</li><li><strong>成员变量：</strong> 在类中，方法外。</li><li><strong>成员方法：</strong> 和以前定义方法是一样的</li></ul><h2 id="1-4-对象的使用"><a href="#1-4-对象的使用" class="headerlink" title="1.4 对象的使用"></a>1.4 对象的使用</h2><p><strong>对象的使用格式</strong></p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名（）；</span><br></pre></td></tr></table></figure><p>使用对象访问类中的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量;</span><br><span class="line">对象名.成员方法();</span><br></pre></td></tr></table></figure><h2 id="1-5成员变量和局部变量区别"><a href="#1-5成员变量和局部变量区别" class="headerlink" title="1.5成员变量和局部变量区别"></a>1.5成员变量和局部变量区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">String name;<span class="comment">//成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//局部变量</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类中的位置不同</p><ul><li>成员变量：类中，方法外。</li><li>局部变量：方法中。</li></ul></li><li><p>作用的范围不一样</p><ul><li>成员变量：类中</li><li>局部变量：方法中</li></ul></li><li><p>初始化默认值</p><ul><li>成员变量：有默认值</li><li>局部变量：没有默认值。必须先定义后赋值，在使用。</li></ul></li><li><p>在内存中的位置不同</p><ul><li>成员变量：堆内存</li><li>局部变量：栈内存</li></ul></li><li><p>生命周期不同</p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着调用的方法完毕而消失</li></ul></li></ul><h1 id="第2章-封装"><a href="#第2章-封装" class="headerlink" title="第2章 封装"></a>第2章 封装</h1><h2 id="2-1-封装概述"><a href="#2-1-封装概述" class="headerlink" title="2.1 封装概述"></a>2.1 封装概述</h2><p><strong>概述</strong></p><p>​        封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><p><strong>原则</strong></p><p>​        将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问</p><h2 id="2-2-封装的步骤"><a href="#2-2-封装的步骤" class="headerlink" title="2.2 封装的步骤"></a>2.2 封装的步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.使用 <span class="keyword">private</span> 关键字来修饰成员变量</span><br><span class="line"><span class="number">2</span>.对需要访问的成员变量，提供对应的get和set方法。</span><br></pre></td></tr></table></figure><h2 id="2-3-封装的操作—-private关键字"><a href="#2-3-封装的操作—-private关键字" class="headerlink" title="2.3 封装的操作—-private关键字"></a>2.3 封装的操作—-private关键字</h2><p><strong>private的含义</strong></p><ol><li>private是一个权限修饰符，代表最小权限</li><li>可以修饰成员变量和成员方法。</li><li>被private修饰后的成员变量和成员方法，只能在本类中使用</li></ol><p><strong>private的使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 变量名;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> ing age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-封装优化1—-this关键字"><a href="#2-4-封装优化1—-this关键字" class="headerlink" title="2.4 封装优化1—-this关键字"></a>2.4 封装优化1—-this关键字</h2><p><strong>this的含义</strong></p><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用</p><p>记住：方法被哪个对象调用，this就代表哪个对象，即谁在调用，this就代表谁</p><p><strong>this使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名</span><br></pre></td></tr></table></figure><h2 id="2-5-封装优化2—-构造方法"><a href="#2-5-封装优化2—-构造方法" class="headerlink" title="2.5 封装优化2—-构造方法"></a>2.5 封装优化2—-构造方法</h2><p>当一个对象被创建的时候，构建方法用来初始化该对象，给对象的成员变量赋值初始值</p><p><strong>构造方法的定义格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line">  <span class="comment">//方法名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name , <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>如果你不提供构造方法，系统会给出无参数构造方法。</li><li>如果你提供了构造方法，系统将不在提供无参数的构造方法</li><li>构造方法可以重载，既可以定义参数，也可以不定义参数</li></ol><h2 id="2-6-标准代码—–JavaBean"><a href="#2-6-标准代码—–JavaBean" class="headerlink" title="2.6 标准代码—–JavaBean"></a>2.6 标准代码—–JavaBean</h2><p>JavaBean是Java语言编写类的一种标准规范。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">//无参构造方法【必须】</span></span><br><span class="line"><span class="comment">//有参构造方法【建议】</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="comment">//getXxx()</span></span><br><span class="line"><span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第3章-Scanner类"><a href="#第3章-Scanner类" class="headerlink" title="第3章 Scanner类"></a>第3章 Scanner类</h1><h2 id="2-1-什么是Scanner类"><a href="#2-1-什么是Scanner类" class="headerlink" title="2.1 什么是Scanner类"></a>2.1 什么是Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in)</span><br><span class="line"><span class="keyword">int</span> i = sc.nextInt();</span><br></pre></td></tr></table></figure><h2 id="2-2-引用类型使用步骤"><a href="#2-2-引用类型使用步骤" class="headerlink" title="2.2 引用类型使用步骤"></a>2.2 引用类型使用步骤</h2><p><strong>创建对象</strong></p><p>使用该类的构造方法，创建一个该类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = <span class="keyword">new</span> 数据类型(参数列表);</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><p>调用该类的成员方法，完成指定功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.方法名()</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = sc.nextInt();</span><br></pre></td></tr></table></figure><h2 id="2-3-匿名对象"><a href="#2-3-匿名对象" class="headerlink" title="2.3 匿名对象"></a>2.3 匿名对象</h2><p><strong>概念</strong></p><p> 创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p><p>匿名对象：没有变量名的对象</p><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ol><li><p>创建匿名对象直接调用方法，没有变量名。</p></li><li><p>一旦调用两次方法，就是创建了两个对象，造成浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Scanner(System.in).nextInt();</span><br><span class="line"><span class="keyword">new</span> Scanner(System.in).nextInt();</span><br></pre></td></tr></table></figure><p>一个匿名对象，只能使用一次</p><p>3.匿名对象可以作为方法的参数和返回值</p></li></ol><h1 id="第3章-Random类"><a href="#第3章-Random类" class="headerlink" title="第3章 Random类"></a>第3章 Random类</h1><h2 id="3-1-什么是Random类"><a href="#3-1-什么是Random类" class="headerlink" title="3.1 什么是Random类"></a>3.1 什么是Random类</h2><p>此类的实例用于生成随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> i = r.nextInt();</span><br></pre></td></tr></table></figure><h2 id="3-2-Random使用步骤"><a href="#3-2-Random使用步骤" class="headerlink" title="3.2 Random使用步骤"></a>3.2 Random使用步骤</h2><p><strong>查看构造方法</strong></p><ul><li>public Random()：创建一个新的随机生成器</li></ul><p><strong>查看成员方法</strong></p><ul><li>public int nextInt(int n)：返回一个伪随机数，范围在0（包括）和 n（不包括）之间的int 值</li></ul><h1 id="第四章-ArrayList类"><a href="#第四章-ArrayList类" class="headerlink" title="第四章 ArrayList类"></a>第四章 ArrayList类</h1><h2 id="4-2-什么是ArrayList类"><a href="#4-2-什么是ArrayList类" class="headerlink" title="4.2 什么是ArrayList类"></a>4.2 什么是ArrayList类</h2><p>java.util.ArrayList是大小可变的数组实现，存储在内的数据称为元素，ArrayList中可不断添加元素，其大小也自动增长。</p><h2 id="4-3-ArrayList使用步骤"><a href="#4-3-ArrayList使用步骤" class="headerlink" title="4.3 ArrayList使用步骤"></a>4.3 ArrayList使用步骤</h2><p><strong>查看类</strong></p><p>java.util.ArrayList&lt; E &gt;: &lt; E &gt;表示一种泛型，使用一种引用数据类型将其替换即可</p><p><strong>查看构造方法</strong></p><p>public ArrayList()：构造一个内容为空的集合</p><p><strong>基本格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>查看成员方法</strong></p><p>public boolean add(E e)：将指定的元素添加到集合的尾部</p><p>在构造ArrayList对象时 &lt; E &gt;指定了什么数据类型，那么add（E e）方法中，只能添加什么类型的对象</p><h2 id="4-4-常用方法和遍历"><a href="#4-4-常用方法和遍历" class="headerlink" title="4.4 常用方法和遍历"></a>4.4 常用方法和遍历</h2><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span><span class="comment">//将指定元素添加到此集合的尾部</span></span><span class="function"><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> E remove(<span class="keyword">int</span> <span class="keyword">index</span>)<span class="comment">//移除此集合中指定位置上的元素。返回被删除的元素</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回此集合中指定位置上的元素。返回获取的元素</span></span><span class="function"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>()<span class="comment">//返回此集合中的元素数</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><h2 id="4-5-如何存储基本数据类型"><a href="#4-5-如何存储基本数据类型" class="headerlink" title="4.5 如何存储基本数据类型"></a>4.5 如何存储基本数据类型</h2><p> ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似  不能写，但是存储基本数据类型对应的 包装类型是可以的。所以，想要存储基本类型数据， &lt;&gt; 中的数据类型，必须转换后才能编写，转换写法如下： </p><table><thead><tr><th>基本数据类型</th><th>基本类型包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h1 id="第五章-String类"><a href="#第五章-String类" class="headerlink" title="第五章 String类"></a>第五章 String类</h1><h2 id="1-1-String类概述"><a href="#1-1-String类概述" class="headerlink" title="1.1 String类概述"></a>1.1 String类概述</h2><p><strong>概述</strong></p><p>String类代表字符串。Java程序中所有的字符串文字（例如“abc”）都可以被看作是实现此类的实例。类String中包括用于检查各个字符串的方法。</p><p><strong>特点</strong></p><ol><li><p>字符串不变：字符串的值在创建后就不能被更改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String S1 = <span class="string">"abc"</span>;</span><br><span class="line">S1 += <span class="string">"d"</span>;</span><br><span class="line">System.out.println(S1);<span class="comment">//"abcd"</span></span><br><span class="line"><span class="comment">//内存中有"abc"和"abcd"两个对象，S1从指向"abc",改变指向"abcd"</span></span><br></pre></td></tr></table></figure></li><li><p>因为String对象是不可变的，所有它可以共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//内存中有"abc"对象被创建，同时被a和b共享</span></span><br></pre></td></tr></table></figure></li><li><p>“abc” 等效于 char[] data = {‘a’,’b’,’c’}.</p></li></ol><h2 id="1-2-使用步骤"><a href="#1-2-使用步骤" class="headerlink" title="1.2 使用步骤"></a>1.2 使用步骤</h2><ul><li><strong>查看构造方法</strong><ul><li>public String()：初始化创建的String对象</li><li>public String(char[] value)：通过当前的字符串数组来构造新的String</li><li>public String(byte[] bytes)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字符数组构造</span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过字节数组构造</span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><p><strong>判断功能的方法</strong></p><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span><span class="comment">//将此字符串与指定的对象进行比较</span></span><span class="function"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(<span class="keyword">String</span> anotherString)</span><span class="comment">//将此字符串与指定对象进行比较，忽略大小写</span></span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><p>–Object是对象的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法 </p><p><strong>获取功能的方法</strong></p><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="comment">//返回此字符串的长度</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">concat</span>(<span class="keyword">String</span> <span class="built_in">str</span>)<span class="comment">//将指定的字符串连接到该字符串的结尾</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span><span class="comment">//返回指定索引处的char值。</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> indexOf(<span class="keyword">String</span> <span class="built_in">str</span>)<span class="comment">//返回字符串第一次出现在该字符串的索引</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span><span class="comment">//返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><span class="function"><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">//返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</span></span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><p><strong>转换功能的方法</strong></p><ul><li><pre><code class="java"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray ()<span class="comment">//将此字符串转换为新的字符数组。</span>&lt;!--￼<span class="number">30</span>--&gt;</code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span><span class="comment">//将与target匹配的字符串使用replacement字符串替换。</span></span><span class="function"><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**分割功能的方法**</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">String</span>[] <span class="built_in">split</span>(<span class="keyword">String</span> regex)<span class="comment">//将此字符串按照给定的regex（规则）拆分为字符串数组。</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul><h1 id="第六章-static关键字"><a href="#第六章-static关键字" class="headerlink" title="第六章 static关键字"></a>第六章 static关键字</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h2><p>​         static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 </p><h2 id="2-2-定义和使用格式"><a href="#2-2-定义和使用格式" class="headerlink" title="2.2 定义和使用格式"></a>2.2 定义和使用格式</h2><p><strong>类变量</strong></p><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 </p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> id；</span><br></pre></td></tr></table></figure><p><strong>静态方法</strong></p><p>当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要 创建类的对象。调用方式非常简单。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123;</span><br><span class="line"><span class="comment">// 执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"num:"</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态方法调用的注意事项： <ul><li>静态方法可以直接访问类变量和静态方法。 </li><li>静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法 </li><li>静态方法中，不能使用this关键字 </li></ul></li></ul><p>静态方法只能访问静态成员</p><p><strong>调用格式</strong></p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名；</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数)；</span><br></pre></td></tr></table></figure><h2 id="2-3-static-修饰的内容："><a href="#2-3-static-修饰的内容：" class="headerlink" title="2.3 static 修饰的内容："></a>2.3 static 修饰的内容：</h2><ul><li>是随着类的加载而加载的，且只加载一次。 </li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 </li><li>它优先于对象存在，所以，可以被所有对象共享。  </li></ul><h2 id="2-4-静态代码块"><a href="#2-4-静态代码块" class="headerlink" title="2.4 静态代码块"></a>2.4 静态代码块</h2><ul><li>静态代码块：定义在成员位置，使用static修饰的代码块{ … }。 <ul><li>位置：类中方法外。 </li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 </li></ul></li></ul><p><strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">// 执行语句</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：</p><p> static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况 下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。  </p><h1 id="第七章-Arrays类"><a href="#第七章-Arrays类" class="headerlink" title="第七章 Arrays类"></a>第七章 Arrays类</h1><h2 id="7-1概述"><a href="#7-1概述" class="headerlink" title="7.1概述"></a>7.1概述</h2><p> Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法。  </p><h2 id="7-2操作数组的方法"><a href="#7-2操作数组的方法" class="headerlink" title="7.2操作数组的方法"></a>7.2操作数组的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span><span class="comment">//返回指定数组内容的字符串表示形式。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span><span class="comment">//对指定的 int 型数组按数字升序进行排序。</span></span></span><br></pre></td></tr></table></figure><h1 id="第八章-Math类"><a href="#第八章-Math类" class="headerlink" title="第八章 Math类"></a>第八章 Math类</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><p> Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具 类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。  </p><h2 id="8-2基本运算方法"><a href="#8-2基本运算方法" class="headerlink" title="8.2基本运算方法"></a>8.2基本运算方法</h2><ul><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回 double 值的绝对值。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.abs(‐<span class="number">5</span>); <span class="comment">//d1的值为5</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">//d2的值为5</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回大于等于参数的最小的整数。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.ceil(‐<span class="number">3.3</span>); <span class="comment">//d2的值为 ‐3.0</span></span><br><span class="line"><span class="built_in">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">//d3的值为 6.0</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回小于等于参数最大的整数。</span></span><span class="function"><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="built_in">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="built_in">double</span> d2 = Math.floor(‐<span class="number">3.3</span>); <span class="comment">//d2的值为‐4.0</span></span><br><span class="line"><span class="built_in">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure></span></code></pre></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span><span class="comment">//返回最接近参数的 long。(相当于四舍五入方法)</span></span><span class="function"><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">long</span> d1 = Math.<span class="keyword">round</span>(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">long</span> d2 = Math.<span class="keyword">round</span>(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure></span><span class="function"></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础（二） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2020/01/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/22/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在复习Java基础，刚刚好也做下笔记，本文介绍什么是Java，Java语言的开发环境，基本的数据类型有哪些，介绍了方法的概述，定义，与调用方法的三种形式，还有三种循环，数组等，再接再厉不服努力加油！！！</p>   <a id="more"></a><h2 id="1-1计算机基础知识"><a href="#1-1计算机基础知识" class="headerlink" title="1.1计算机基础知识"></a>1.1计算机基础知识</h2><p>​        <strong>字节</strong>： 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性， 我们可以查看文件的字节大小。 </p><p> 8 bit = 1 B ，1024 B =1 KB ，1024 KB =1 MB ，1024 MB =1 GB ，1024 GB = 1 TB </p><p>​        <strong>常用DOS命令</strong>：</p><table><thead><tr><th>命令</th><th>操作符号</th></tr></thead><tbody><tr><td>盘符切换命令</td><td>D：</td></tr><tr><td>查看当前文件夹</td><td>dir</td></tr><tr><td>进入文件夹命令</td><td>cd 文件夹名</td></tr><tr><td>退出文件夹命令</td><td>cd..</td></tr><tr><td>退出磁盘根目录</td><td>cd\</td></tr><tr><td>清屏</td><td>cls</td></tr></tbody></table><h1 id="第二章Java语言开发环境"><a href="#第二章Java语言开发环境" class="headerlink" title="第二章Java语言开发环境"></a>第二章Java语言开发环境</h1><h2 id="2-1-Java虚拟机–JVM"><a href="#2-1-Java虚拟机–JVM" class="headerlink" title="2.1  Java虚拟机–JVM"></a>2.1  Java虚拟机–JVM</h2><p>​        <strong>JVM</strong>： ：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 </p><h2 id="2-2-JRE和JDK"><a href="#2-2-JRE和JDK" class="headerlink" title="2.2 JRE和JDK"></a>2.2 JRE和JDK</h2><pre><code>**· JRE**： 是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 </code></pre><p>​    <strong>· JDK</strong>：  是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 </p><p>​    三者关系： JDK&gt;JRE&gt;JVM</p><h1 id="第三章程序说明"><a href="#第三章程序说明" class="headerlink" title="第三章程序说明"></a>第三章程序说明</h1><h2 id="3-1编译和运行是两回事"><a href="#3-1编译和运行是两回事" class="headerlink" title="3.1编译和运行是两回事"></a>3.1编译和运行是两回事</h2><p>​            <strong>·  编译：</strong>是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们 所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。 </p><p>​            <strong>·运行</strong>：是指将 class文件 交给JVM去运行，此时JVM就会去执行我们编写的程序了。</p><h2 id="3-2关于main方法"><a href="#3-2关于main方法" class="headerlink" title="3.2关于main方法"></a>3.2关于main方法</h2><p>​         <strong>main方法</strong>：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多 少程序，JVM在运行的时候，都会从main方法这里开始执行。</p><h2 id="3-3关键字keywords"><a href="#3-3关键字keywords" class="headerlink" title="3.3关键字keywords"></a>3.3关键字keywords</h2><p>​         <strong>关键字</strong>：是指在程序中，Java已经定义好的单词，具有特殊含义。 HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被 Java定义好，全部都是小写字母，notepad++中颜色特殊。   </p><h2 id="3-4-标识符"><a href="#3-4-标识符" class="headerlink" title="3.4 标识符"></a>3.4 标识符</h2><p> <strong>标识符：</strong>是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 </p><p> <strong>命名规则：</strong> <strong>硬性要求</strong> </p><p>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字 </p><p> <strong>命名规范： 软性建议</strong> </p><p>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。 </p><h1 id="第四章变量和数据类型"><a href="#第四章变量和数据类型" class="headerlink" title="第四章变量和数据类型"></a>第四章变量和数据类型</h1><h2 id="5-1数据类型"><a href="#5-1数据类型" class="headerlink" title="5.1数据类型"></a>5.1数据类型</h2><h3 id="Java的数据类型分为两大类"><a href="#Java的数据类型分为两大类" class="headerlink" title="Java的数据类型分为两大类"></a>Java的数据类型分为两大类</h3><p>​    <strong>基本数据类型：</strong>包括 整数、浮点数、字符、布尔。</p><p>​    <strong>引用数据类型：</strong>包括 类、数组、接口。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="四类八种基本数据类型"><a href="#四类八种基本数据类型" class="headerlink" title="四类八种基本数据类型"></a>四类八种基本数据类型</h4><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1个字节</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2个字节</td><td>-32768~32767</td></tr><tr><td>整型</td><td>int</td><td>4个字节</td><td>-231次方~2的31次方-1</td></tr><tr><td>长整型</td><td>long</td><td>8个字节</td><td>-2的63次方~2的63次方-1</td></tr><tr><td>单精度浮点数</td><td>folat</td><td>4个字节</td><td>1.4013E-45~3.4028E+38</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8个字节</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字节型</td><td>char</td><td>2个字节</td><td>0-65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>1个字节</td><td>true，false</td></tr></tbody></table><p>Java中的默认类型： 整数类型是int，浮点类型是double</p><h2 id="5-2变量的定义"><a href="#5-2变量的定义" class="headerlink" title="5.2变量的定义"></a>5.2变量的定义</h2><p> <strong>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</strong> </p><p>变量定义的格式包括三个要素： 数据类型、变量名、数据值。</p><p><strong>格式</strong>： <strong>数据类型 变量名 = 数据值；</strong></p><h2 id="5-3注意事项"><a href="#5-3注意事项" class="headerlink" title="5.3注意事项"></a>5.3注意事项</h2><p><strong>变量名称：在同一个大括号范围内，变量的名字不可以相同</strong></p><p><strong>变量赋值：定义是变量，不赋值不能使用。</strong></p><h1 id="第五章-方法"><a href="#第五章-方法" class="headerlink" title="第五章 方法"></a>第五章 方法</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p> 我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。</p><p>​         <strong>方法：</strong>就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。 当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 </p><h2 id="5-2方法的定义"><a href="#5-2方法的定义" class="headerlink" title="5.2方法的定义"></a>5.2方法的定义</h2><p> <strong>定义格式：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">代码...</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li>修饰符：public static</li><li>返回值类型：表示方法运行的结果的数据类型，方法执行后将结果返回到调用者</li><li>参数列表：方法在运行过程中未知数据，调用者调用方法时传递</li><li>return：将方法执行后的结果带给调用者，方法执行到return，整体方法运行结束</li></ul><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"这是一个方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3方法的调用"><a href="#5-3方法的调用" class="headerlink" title="5.3方法的调用"></a>5.3方法的调用</h2><p>​     <strong>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在 主方法中，直接写要调用的方法名字就可以调用了</strong>。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用定义的方法method</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法，被main方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"自己定义的方法，需要被main调用运行"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4调用方法的三种形式"><a href="#5-4调用方法的三种形式" class="headerlink" title="5.4调用方法的三种形式"></a>5.4调用方法的三种形式</h2><ul><li><p><strong>直接调用：</strong>直接写方法名调用</p></li><li><pre><code class="Java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{    print();}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{    System.out.println(<span class="string">"方法被调用"</span>);}&lt;!--￼<span class="number">3</span>--&gt;</code></pre></li><li><p><strong>输出语句调用：</strong> 在输出语句中调用方法， System.out.println(方法名()) 。 </p></li></ul><h2 id="5-5方法重载"><a href="#5-5方法重载" class="headerlink" title="5.5方法重载"></a>5.5方法重载</h2><ul><li><p><strong>方法重载：</strong> 指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关。  </p></li><li><p>参数列表：个数不同，数据类型不同，顺序不同。 </p></li><li><p>重载方法调用：JVM通过方法的参数列表，调用不同的方法。 </p></li><li><p>如：</p></li><li><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>{}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a)</span></span>{}<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span></span>{}&lt;!--￼<span class="number">4</span>--&gt;</code></pre></li></ul><h2 id="6-2循环语句–while"><a href="#6-2循环语句–while" class="headerlink" title="6.2循环语句–while"></a>6.2循环语句–while</h2><p> <strong>while循环语句格式：</strong>  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(布尔表达式②)</span></span>&#123;</span><br><span class="line">循环体③</span><br><span class="line">步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3循环语句–do…while"><a href="#6-3循环语句–do…while" class="headerlink" title="6.3循环语句–do…while"></a>6.3循环语句–do…while</h2><p> <strong>do…while循环格式</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体③</span><br><span class="line">步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><h2 id="6-4循环语句的区别"><a href="#6-4循环语句的区别" class="headerlink" title="6.4循环语句的区别"></a>6.4循环语句的区别</h2><p> <strong>for 和 while 的小区别：</strong> </p><p>​        控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。</p><p>​         在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 </p><h2 id="6-5跳出语句"><a href="#6-5跳出语句" class="headerlink" title="6.5跳出语句"></a>6.5跳出语句</h2><p><strong>break</strong></p><p>​    <strong>使用场景：终止switch或者循环</strong></p><p>​                 在选择结构switch语句中 </p><p>​                 在循环语句中 </p><p>​                 离开使用场景的存在是没有意义的 </p><p><strong>continue</strong></p><p>​        <strong>使用场景：结束本次循环，继续下一次的循环</strong></p><h1 id="第7章数组"><a href="#第7章数组" class="headerlink" title="第7章数组"></a>第7章数组</h1><h2 id="7-1数组定义和访问"><a href="#7-1数组定义和访问" class="headerlink" title="7.1数组定义和访问"></a>7.1数组定义和访问</h2><h3 id="7-1-1容器概述"><a href="#7-1-1容器概述" class="headerlink" title="7.1.1容器概述"></a>7.1.1容器概述</h3><p><strong>容器概念</strong>：</p><p>​        <strong>容器：</strong>是将多个数据储存到一起，每个数据称为该容器的元素。</p><h3 id="7-1-2数组的概念"><a href="#7-1-2数组的概念" class="headerlink" title="7.1.2数组的概念"></a>7.1.2数组的概念</h3><p> <strong>数组概念：</strong> 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</p><h3 id="7-1-3数组的定义"><a href="#7-1-3数组的定义" class="headerlink" title="7.1.3数组的定义"></a>7.1.3数组的定义</h3><p><strong>方式一</strong></p><p>​        <strong>格式：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br></pre></td></tr></table></figure><ul><li><strong>数组定义格式详解：</strong><ul><li>数组存储的数据类型：创建的数组可以储存什么数据类型。</li><li>[]：表示数组</li><li>数组名字：为定义的数据起一个变量名，满足标识符规范，可以使用名字操作数组</li><li>new：关键字，创建数组的关键字</li><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。 </li><li><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong> </li></ul></li></ul><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><p>​        <strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>...&#125;;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> intp[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>方式三</strong></p><p>​        <strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>...&#125;;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-1-4-数组的访问"><a href="#7-1-4-数组的访问" class="headerlink" title="7.1.4 数组的访问"></a>7.1.4 数组的访问</h3><ul><li><p><strong>索引：</strong> 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为<strong>数组索引 (index)</strong>，可以通过数组的索引访问到数组中的元素。 </p></li><li><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure></li><li><p><strong>数组的长度：</strong> 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： <strong>数组名.length</strong> </p></li></ul><h2 id="7-2数组原理内存"><a href="#7-2数组原理内存" class="headerlink" title="7.2数组原理内存"></a>7.2数组原理内存</h2><h3 id="7-2-1内存概述"><a href="#7-2-1内存概述" class="headerlink" title="7.2.1内存概述"></a>7.2.1内存概述</h3><p>​         内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。 Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。 </p><h3 id="7-2-2Java虚拟机的内存划分"><a href="#7-2-2Java虚拟机的内存划分" class="headerlink" title="7.2.2Java虚拟机的内存划分"></a>7.2.2Java虚拟机的内存划分</h3><p>​         为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 </p><table><thead><tr><th>区域名称</th><th>作用</th></tr></thead><tbody><tr><td>寄存器</td><td>给CPU使用，和我们开发无关。</td></tr><tr><td>本地方法栈</td><td>JVM在使用操作系统功能的时候使用，和我们开发无关</td></tr><tr><td>方法区</td><td>存储可以运行的class文件。</td></tr><tr><td>堆内存</td><td>存储对象或者数组，new来创建的，都存储在堆内存。</td></tr><tr><td>方法栈</td><td>方法运行时使用的内存，比如main方法运行。</td></tr></tbody></table><h3 id="7-2-3数组的常见操作"><a href="#7-2-3数组的常见操作" class="headerlink" title="7.2.3数组的常见操作"></a>7.2.3数组的常见操作</h3><ul><li><strong>数据越界异常</strong></li><li><strong>数组空指针异常</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础（一） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的一年新的开始！</title>
      <link href="/2020/01/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2020/01/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新的一年就要来啦！！请你一定不要停下来成为你想成为的人。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
